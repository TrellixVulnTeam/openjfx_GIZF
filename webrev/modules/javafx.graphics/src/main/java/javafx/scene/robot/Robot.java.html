<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New modules/javafx.graphics/src/main/java/javafx/scene/robot/Robot.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 package javafx.scene.robot;
  26 
  27 import static com.sun.javafx.FXPermissions.CREATE_ROBOT_PERMISSION;
  28 
  29 import java.nio.IntBuffer;
  30 
  31 import javafx.geometry.Point2D;
  32 import javafx.geometry.Rectangle2D;
  33 import javafx.geometry.VerticalDirection;
  34 import javafx.scene.image.Image;
  35 import javafx.scene.input.KeyCode;
  36 import javafx.scene.input.MouseButton;
  37 import javafx.scene.paint.Color;
  38 import javafx.stage.Screen;
  39 
  40 import com.sun.glass.ui.Application;
  41 import com.sun.glass.ui.GlassRobot;
  42 
  43 /**
  44  * A {@code Robot} is used for simulating user interaction such as
  45  * typing keys on the keyboard and using the mouse as well as capturing
  46  * graphical information without requiring a {@link javafx.scene.Scene}
  47  * instance.
  48  * &lt;p&gt;
  49  * A {@code Robot} instance can be obtained by calling
  50  * {@link javafx.application.Application#createRobot()}.
  51  *
  52  * @since 11
  53  */
  54 public abstract class Robot {
  55 
  56     /**
  57      * Initializes any state necessary for this {@code Robot}. Called by
  58      * the {@code Robot} constructor.
  59      */
  60     protected abstract void create();
  61 
  62     protected Robot() {
  63         // Ensure we have proper permission for creating a robot.
  64         final SecurityManager sm = System.getSecurityManager();
  65         if (sm != null) {
  66             sm.checkPermission(CREATE_ROBOT_PERMISSION);
  67         }
  68 
  69         Application.checkEventThread();
  70         create();
  71     }
  72 
  73     /**
  74      * Frees any resources allocated by this {@code Robot}.
  75      */
  76     protected abstract void destroy();
  77 
  78     /**
  79      * Presses the specified {@link KeyCode} key.
  80      *
  81      * @param keyCode the key to press
  82      */
  83     public abstract void keyPress(KeyCode keyCode);
  84 
  85     /**
  86      * Releases the specified {@link KeyCode} key.
  87      *
  88      * @param keyCode the key to release
  89      */
  90     public abstract void keyRelease(KeyCode keyCode);
  91 
  92     /**
  93      * Types the specified {@link KeyCode} key.
  94      * &lt;p&gt;
  95      * This is a convenience method that is equivalent to calling
  96      * {@link #keyPress(KeyCode)} followed by {@link #keyRelease(KeyCode)}.
  97      *
  98      * @param keyCode the key to type
  99      */
 100     public final void keyType(KeyCode keyCode) {
 101         Application.checkEventThread();
 102         keyPress(keyCode);
 103         keyRelease(keyCode);
 104     }
 105 
 106     /**
 107      * Returns the current mouse x-position.
 108      *
 109      * @return the current mouse x-position
 110      */
 111     public abstract int getMouseX();
 112 
 113     /**
 114      * Returns the current mouse y-position.
 115      *
 116      * @return the current mouse y-position
 117      */
 118     public abstract int getMouseY();
 119 
 120     /**
 121      * Returns the current mouse (x, y) coordinates as a {@link Point2D}.
 122      *
 123      * @return the current mouse (x,y) coordinates
 124      */
 125     public Point2D getMousePosition() {
 126         Application.checkEventThread();
 127         return new Point2D(getMouseX(), getMouseY());
 128     }
 129 
 130     /**
 131      * Moves the mouse to the specified (x,y) screen coordinates.
 132      *
 133      * @param x screen coordinate x to move the mouse to
 134      * @param y screen coordinate y to move the mouse to
 135      */
 136     public abstract void mouseMove(int x, int y);
 137 
 138     /**
 139      * Moves the mouse to the (x,y) screen coordinates specified by the
 140      * given {@code location}.
 141      *
 142      * @param location the (x,y) coordinates to move the mouse to
 143      */
 144     public final void mouseMove(Point2D location) {
 145         Application.checkEventThread();
 146         mouseMove((int) location.getX(), (int) location.getY());
 147     }
 148 
 149     /**
 150      * Presses the specified {@link MouseButton}.
 151      *
 152      * @param button the mouse button to press
 153      */
 154     public abstract void mousePress(MouseButton button);
 155 
 156     /**
 157      * Presses the specified {@link MouseButton}s at the same time.
 158      *
 159      * @param buttons the mouse buttons to press at the same time
 160      */
 161     public abstract void mousePress(MouseButton... buttons);
 162 
 163     /**
 164      * Releases the specified {@link MouseButton}.
 165      *
 166      * @param button the mouse button to release
 167      */
 168     public abstract void mouseRelease(MouseButton button);
 169 
 170     /**
 171      * Releases the specified {@link MouseButton}s at the same time.
 172      *
 173      * @param buttons the mouse buttons to release at the same time
 174      */
 175     public abstract void mouseRelease(MouseButton... buttons);
 176 
 177     /**
 178      * Scrolls the mouse wheel by the specified amount in the specified vertical
 179      * {@code direction}.
 180      *
 181      * @param wheelAmt the amount to scroll the wheel
 182      * @param direction the vertical direction, either up or down, to scroll in
 183      */
 184     public final void mouseWheel(int wheelAmt, VerticalDirection direction) {
 185         Application.checkEventThread();
 186         switch (direction) {
 187             case UP:
 188                 mouseWheel(wheelAmt);
 189                 break;
 190             case DOWN:
 191                 mouseWheel(-wheelAmt);
 192                 break;
 193             default: throw new IllegalArgumentException("unsupported direction: " + direction);
 194         }
 195     }
 196 
 197     /**
 198      * Scrolls the mouse wheel by the specified amount. Positive {@code wheelAmt}s
 199      * scroll up whereas negative scroll down.
 200      *
 201      * @param wheelAmt the (signed) amount to scroll the wheel
 202      */
 203     protected abstract void mouseWheel(int wheelAmt);
 204 
 205     /**
 206      * Returns the {@link Color} of the pixel at the specified screen coordinates.
 207      *
 208      * @param x the x coordinate to get the pixel color from
 209      * @param y the y coordinate to get the pixel color from
 210      * @return the pixel color at the specified screen coordinates
 211      */
 212     public abstract Color getPixelColor(int x, int y);
 213 
 214     /**
 215      * Returns the {@link Color} of the pixel at the screen coordinates specified
 216      * by {@code location}.
 217      *
 218      * @param location the (x,y) coordinates to get the pixel color from
 219      * @return the pixel color at the specified screen coordinates
 220      */
 221     public final Color getPixelColor(Point2D location) {
 222         Application.checkEventThread();
 223         return getPixelColor((int) location.getX(), (int) location.getY());
 224     }
 225 
 226     /**
 227      * Returns an {@code Image} containing the specified rectangular area of the screen.
 228      * &lt;p&gt;
 229      * If the {@code scaleToFit} argument is {@literal false}, the returned
 230      * {@code Image} object dimensions may differ from the requested {@code width}
 231      * and {@code height} depending on how many physical pixels the area occupies
 232      * on the screen. E.g. in HiDPI mode on the Mac (aka Retina display) the pixels
 233      * are doubled, and thus a screen capture of an area of size (10x10) pixels
 234      * will result in an {@code Image} with dimensions (20x20). Calling code should
 235      * use the returned images's {@link Image#getWidth() and {@link Image#getHeight()
 236      * methods to determine the actual image size.
 237      * &lt;p&gt;
 238      * If {@code scaleToFit} is {@literal true}, the returned {@code Image} is of
 239      * the requested size. Note that in this case the image will be scaled in
 240      * order to fit to the requested dimensions if necessary such as when running
 241      * on a HiDPI display.
 242      *
 243      * @param x the starting x-position of the rectangular area to capture
 244      * @param y the starting y-position of the rectangular area to capture
 245      * @param width the width of the rectangular area to capture
 246      * @param height the height of the rectangular area to capture
 247      * @param scaleToFit If {@literal true} the returned {@code Image} will be
 248      * scaled to fit the request dimensions, if necessary. Otherwise the size
 249      * of the returned image will depend on the output scale (DPI) of the primary
 250      * screen.
 251      */
 252     public final Image getScreenCapture(int x, int y, int width, int height, boolean scaleToFit) {
 253         Application.checkEventThread();
 254         Screen primaryScreen = Screen.getPrimary();
 255         double outputScaleX = primaryScreen.getOutputScaleX();
 256         double outputScaleY = primaryScreen.getOutputScaleY();
 257         int data[];
 258         int dw, dh;
 259         if (outputScaleX == 1.0f &amp;&amp; outputScaleY == 1.0f) {
 260             // No scaling with be necessary regardless of if "scaleToFit" is set or not.
 261             data = new int[width * height];
 262             getScreenCapture(x, y, width, height, data);
 263             dw = width;
 264             dh = height;
 265         } else {
 266             // Compute the absolute pixel bounds that the requested size will fill given
 267             // the display's scale.
 268             int pminx = (int) Math.floor(x * outputScaleX);
 269             int pminy = (int) Math.floor(y * outputScaleY);
 270             int pmaxx = (int) Math.ceil((x + width) * outputScaleX);
 271             int pmaxy = (int) Math.ceil((y + height) * outputScaleY);
 272             int pwidth = pmaxx - pminx;
 273             int pheight = pmaxy - pminy;
 274             int tmpdata[] = new int[pwidth * pheight];
 275             getScreenCapture(pminx, pminy, pwidth, pheight, tmpdata);
 276             if (!scaleToFit) {
 277                 data = tmpdata;
 278                 dw = pwidth;
 279                 dh = pheight;
 280             } else {
 281                 // We must resize the image to fit the requested bounds. This means
 282                 // resizing the pixel data array which we accomplish using bilinear (?)
 283                 // interpolation.
 284                 data = new int[width * height];
 285                 int index = 0;
 286                 for (int iy = 0; iy &lt; height; iy++) {
 287                     double rely = ((y + iy + 0.5f) * outputScaleY) - (pminy + 0.5f);
 288                     int irely = (int) Math.floor(rely);
 289                     int fracty = (int) ((rely - irely) * 256);
 290                     for (int ix = 0; ix &lt; width; ix++) {
 291                         double relx = ((x + ix + 0.5f) * outputScaleX) - (pminx + 0.5f);
 292                         int irelx = (int) Math.floor(relx);
 293                         int fractx = (int) ((relx - irelx) * 256);
 294                         data[index++] =
 295                                 GlassRobot.interp(tmpdata, irelx, irely, pwidth, pheight, fractx, fracty);
 296                     }
 297                 }
 298                 dw = width;
 299                 dh = height;
 300             }
 301         }
 302 
 303         return GlassRobot.convertFromPixels(Application.GetApplication().createPixels(
 304                 dw, dh, IntBuffer.wrap(data)));
 305     }
 306 
 307     /**
 308      * Returns an {@code Image} containing the specified rectangular area of the screen.
 309      * &lt;p&gt;
 310      * It is equivalent to calling {@code getScreenCapture(x, y, width, height, true)},
 311      * i.e. this method scales the image to fit the requested size.
 312      *
 313      * @param x the starting x-position of the rectangular area to capture
 314      * @param y the starting y-position of the rectangular area to capture
 315      * @param width the width of the rectangular area to capture
 316      * @param height the height of the rectangular area to capture
 317      * @return the screen capture of the specified {@code region} as an {@link Image}
 318      */
 319     public final Image getScreenCapture(int x, int y, int width, int height) {
 320         Application.checkEventThread();
 321         return getScreenCapture(x, y, width, height, true);
 322     }
 323 
 324     /**
 325      * Returns an {@code Image} containing the specified rectangular area of the screen.
 326      * &lt;p&gt;
 327      * It is equivalent to calling {@code getScreenCapture(x, y, width, height, true)},
 328      * i.e. this method scales the image to fit the requested size.
 329      *
 330      * @param region the rectangular area of the screen to capture
 331      * @return the screen capture of the specified {@code region} as an {@link Image}
 332      */
 333     public final Image getScreenCapture(Rectangle2D region) {
 334         Application.checkEventThread();
 335         return getScreenCapture((int) region.getMinX(), (int) region.getMinY(),
 336                 (int) region.getWidth(), (int) region.getHeight(), true);
 337     }
 338 
 339     /**
 340      * Returns an {@code Image} containing the specified rectangular area of the screen.
 341      * &lt;p&gt;
 342      * If the {@code scaleToFit} argument is {@literal false}, the returned
 343      * {@code Image} object dimensions may differ from the requested {@code width}
 344      * and {@code height} depending on how many physical pixels the area occupies
 345      * on the screen. E.g. in HiDPI mode on the Mac (aka Retina display) the pixels
 346      * are doubled, and thus a screen capture of an area of size (10x10) pixels
 347      * will result in an {@code Image} with dimensions (20x20). Calling code should
 348      * use the returned images's {@link Image#getWidth() and {@link Image#getHeight()
 349      * methods to determine the actual image size.
 350      * &lt;p&gt;
 351      * If {@code scaleToFit} is {@literal true}, the returned {@code Image} is of
 352      * the requested size. Note that in this case the image will be scaled in
 353      * order to fit to the requested dimensions if necessary such as when running
 354      * on a HiDPI display.
 355      *
 356      * @param region the rectangular area of the screen to capture
 357      * @param scaleToFit If {@literal true} the returned {@code Image} will be
 358      * scaled to fit the request dimensions, if necessary. Otherwise the size
 359      * of the returned image will depend on the output scale (DPI) of the primary
 360      * screen.
 361      * @return the screen capture of the specified {@code region} as an {@link Image}
 362      */
 363     public final Image getScreenCapture(Rectangle2D region, boolean scaleToFit) {
 364         Application.checkEventThread();
 365         return getScreenCapture((int) region.getMinX(), (int) region.getMinY(),
 366                 (int) region.getWidth(), (int) region.getHeight(), scaleToFit);
 367     }
 368 
 369     /**
 370      * Captures the specified rectangular area of the screen and uses it to fill the given
 371      * {@code data} array with the raw pixel data. The data is in RGBA format where each
 372      * pixel in the image is encoded as 4 bytes - one for each color component of each
 373      * pixel.
 374      *
 375      * @param x the starting x-position of the rectangular area to capture
 376      * @param y the starting y-position of the rectangular area to capture
 377      * @param width the width of the rectangular area to capture
 378      * @param height the height of the rectangular area to capture
 379      * @param data the array to fill with the raw pixel data corresponding to
 380      * the captured region
 381      */
 382     protected abstract void getScreenCapture(int x, int y, int width, int height, int[] data);
 383 }
</pre></body></html>
