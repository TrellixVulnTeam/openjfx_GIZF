--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/MonocleRobot.java	2018-01-01 14:51:25.628876700 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/MonocleRobot.java	2018-01-01 14:51:25.246855100 -0700
@@ -26,9 +26,12 @@
 package com.sun.glass.ui.monocle;
 
 import com.sun.glass.events.MouseEvent;
-import com.sun.glass.ui.Pixels;
-import com.sun.glass.ui.Robot;
-import javafx.application.Platform;
+import com.sun.glass.ui.Application;
+import com.sun.glass.ui.GlassRobot;
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.MouseButton;
+import javafx.scene.paint.Color;
+import javafx.scene.robot.Robot;
 
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
@@ -36,121 +39,177 @@
 
 class MonocleRobot extends Robot {
     @Override
-    protected void _create() {
+    public void create() {
+        // no-op
     }
 
     @Override
-    protected void _destroy() {
+    public void destroy() {
+        // no-op
     }
 
     @Override
-    protected void _keyPress(int code) {
-        Platform.runLater(() -> {
-            KeyState state = new KeyState();
-            KeyInput.getInstance().getState(state);
-            state.pressKey(code);
-            KeyInput.getInstance().setState(state);
-        });
+    public void keyPress(KeyCode code) {
+        Application.checkEventThread();
+        KeyState state = new KeyState();
+        KeyInput.getInstance().getState(state);
+        state.pressKey(code.getCode());
+        KeyInput.getInstance().setState(state);
     }
 
     @Override
-    protected void _keyRelease(int code) {
-        Platform.runLater(() -> {
-            KeyState state = new KeyState();
-            KeyInput.getInstance().getState(state);
-            state.releaseKey(code);
-            KeyInput.getInstance().setState(state);
-        });
+    public void keyRelease(KeyCode code) {
+        Application.checkEventThread();
+        KeyState state = new KeyState();
+        KeyInput.getInstance().getState(state);
+        state.releaseKey(code.getCode());
+        KeyInput.getInstance().setState(state);
     }
 
     @Override
-    protected void _mouseMove(int x, int y) {
-        Platform.runLater(() -> {
-            MouseState state = new MouseState();
-            MouseInput.getInstance().getState(state);
-            state.setX(x);
-            state.setY(y);
-            MouseInput.getInstance().setState(state, false);
-        });
+    public void mouseMove(int x, int y) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        state.setX(x);
+        state.setY(y);
+        MouseInput.getInstance().setState(state, false);
     }
 
-    @Override
-    protected void _mousePress(int buttons) {
-        Platform.runLater(() -> {
-            MouseState state = new MouseState();
-            MouseInput.getInstance().getState(state);
-            if ((buttons & MOUSE_LEFT_BTN) != 0) {
-                state.pressButton(MouseEvent.BUTTON_LEFT);
-            }
-            if ((buttons & MOUSE_MIDDLE_BTN) != 0) {
-                state.pressButton(MouseEvent.BUTTON_OTHER);
-            }
-            if ((buttons & MOUSE_RIGHT_BTN) != 0) {
-                state.pressButton(MouseEvent.BUTTON_RIGHT);
+    private static MouseState convertToMouseState(boolean press, MouseState state, MouseButton button) {
+        switch (button) {
+            case PRIMARY:
+                if (press) {
+                    state.pressButton(MouseEvent.BUTTON_LEFT);
+                } else {
+                    state.releaseButton(MouseEvent.BUTTON_LEFT);
+                }
+                return state;
+            case SECONDARY:
+                if (press) {
+                    state.pressButton(MouseEvent.BUTTON_RIGHT);
+                } else {
+                    state.releaseButton(MouseEvent.BUTTON_RIGHT);
+                }
+                return state;
+            case MIDDLE:
+                if (press) {
+                    state.pressButton(MouseEvent.BUTTON_OTHER);
+                } else {
+                    state.releaseButton(MouseEvent.BUTTON_OTHER);
+                }
+                return state;
+            default: throw new IllegalArgumentException("MouseButton: " + button +
+                    " not supported by Monocle Robot");
+        }
+    }
+
+    private static MouseState convertToMouseState(boolean press, MouseState state, MouseButton... buttons) {
+        for (MouseButton button : buttons) {
+            switch (button) {
+                case PRIMARY:
+                    if (press) {
+                        state.pressButton(MouseEvent.BUTTON_LEFT);
+                    } else {
+                        state.releaseButton(MouseEvent.BUTTON_LEFT);
+                    }
+                    break;
+                case SECONDARY:
+                    if (press) {
+                        state.pressButton(MouseEvent.BUTTON_RIGHT);
+                    } else {
+                        state.releaseButton(MouseEvent.BUTTON_RIGHT);
+                    }
+                    break;
+                case MIDDLE:
+                    if (press) {
+                        state.pressButton(MouseEvent.BUTTON_OTHER);
+                    } else {
+                        state.releaseButton(MouseEvent.BUTTON_OTHER);
+                    }
+                    break;
+                default: throw new IllegalArgumentException("MouseButton: " + button +
+                        " not supported by Monocle Robot");
             }
-            MouseInput.getInstance().setState(state, false);
-        });
+        }
+        return state;
     }
 
     @Override
-    protected void _mouseRelease(int buttons) {
-        Platform.runLater(() -> {
-            MouseState state = new MouseState();
-            MouseInput.getInstance().getState(state);
-            if ((buttons & MOUSE_LEFT_BTN) != 0) {
-                state.releaseButton(MouseEvent.BUTTON_LEFT);
-            }
-            if ((buttons & MOUSE_MIDDLE_BTN) != 0) {
-                state.releaseButton(MouseEvent.BUTTON_OTHER);
-            }
-            if ((buttons & MOUSE_RIGHT_BTN) != 0) {
-                state.releaseButton(MouseEvent.BUTTON_RIGHT);
-            }
-            MouseInput.getInstance().setState(state, false);
-        });
+    public void mousePress(MouseButton button) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        MouseInput.getInstance().setState(convertToMouseState(true, state, button), false);
     }
 
     @Override
-    protected void _mouseWheel(int wheelAmt) {
-        Platform.runLater(() -> {
-            MouseState state = new MouseState();
-            MouseInput mouse = MouseInput.getInstance();
-            mouse.getState(state);
-            int direction = wheelAmt < 0
-                            ? MouseState.WHEEL_DOWN
-                            : MouseState.WHEEL_UP;
-            for (int i = 0; i < Math.abs(wheelAmt); i++) {
-                state.setWheel(direction);
-                mouse.setState(state, false);
-                state.setWheel(MouseState.WHEEL_NONE);
-                mouse.setState(state, false);
-            }
-        });
+    public void mousePress(MouseButton... buttons) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        MouseInput.getInstance().setState(convertToMouseState(true, state, buttons), false);
+    }
+
+    @Override
+    public void mouseRelease(MouseButton button) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        MouseInput.getInstance().setState(convertToMouseState(false, state, button), false);
+    }
+
+    @Override
+    public void mouseRelease(MouseButton... buttons) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        MouseInput.getInstance().setState(convertToMouseState(false, state, buttons), false);
     }
 
     @Override
-    protected int _getMouseX() {
+    protected void mouseWheel(int wheelAmt) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput mouse = MouseInput.getInstance();
+        mouse.getState(state);
+        int direction = wheelAmt < 0
+                        ? MouseState.WHEEL_DOWN
+                        : MouseState.WHEEL_UP;
+        for (int i = 0; i < Math.abs(wheelAmt); i++) {
+            state.setWheel(direction);
+            mouse.setState(state, false);
+            state.setWheel(MouseState.WHEEL_NONE);
+            mouse.setState(state, false);
+        }
+    }
+
+    @Override
+    public int getMouseX() {
+        Application.checkEventThread();
         MouseState state = new MouseState();
         MouseInput.getInstance().getState(state);
         return state.getX();
     }
 
     @Override
-    protected int _getMouseY() {
+    public int getMouseY() {
+        Application.checkEventThread();
         MouseState state = new MouseState();
         MouseInput.getInstance().getState(state);
         return state.getY();
     }
 
     @Override
-    protected int _getPixelColor(int x, int y) {
+    public Color getPixelColor(int x, int y) {
+        Application.checkEventThread();
         NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
         final int byteDepth = screen.getDepth() >>> 3;
         final int bwidth = screen.getWidth();
         final int bheight = screen.getHeight();
 
         if (x < 0 || x > bwidth || y < 0 || y > bheight) {
-            return 0;
+            return GlassRobot.convertFromIntArgb(0);
         }
 
         synchronized (NativeScreen.framebufferSwapLock) {
@@ -161,29 +220,28 @@
                 ShortBuffer shortbuf = buffer.asShortBuffer();
 
                 int v = shortbuf.get((y * bwidth) + x);
-                int red = (int) ((v & 0xF800) >> 11) << 3;
-                int green = (int) ((v & 0x7E0) >> 5) << 2;
-                int blue = (int) (v & 0x1F) << 3;
+                int red = (v & 0xF800) >> 11 << 3;
+                int green = (v & 0x7E0) >> 5 << 2;
+                int blue = (v & 0x1F) << 3;
 
                 int p = (0xff000000
                         | (red << 16)
                         | (green << 8)
                         | blue);
-                return p;
+                return GlassRobot.convertFromIntArgb(p);
             } else if (byteDepth >= 4) {
                 IntBuffer intbuf = buffer.asIntBuffer();
-                return intbuf.get((y * bwidth) + x);
+                return GlassRobot.convertFromIntArgb(intbuf.get((y * bwidth) + x));
             } else {
-                throw new RuntimeException("Unknown bit depth");
+                throw new RuntimeException("Unknown bit depth: " + byteDepth);
             }
         }
     }
 
     @Override
-    protected Pixels _getScreenCapture(int x, int y, int width, int height,
-            boolean isHiDPI) {
+    protected void getScreenCapture(int x, int y, int width, int height, int[] data) {
+        Application.checkEventThread();
         NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
-        final int byteDepth = screen.getDepth() >>> 3;
         final int scrWidth = screen.getWidth();
         final int scrHeight = screen.getHeight();
 
@@ -191,20 +249,18 @@
             IntBuffer buffer = screen.getScreenCapture().asIntBuffer();
 
             if (x == 0 && y == 0 && width == scrWidth && height == scrHeight) {
-                return new MonoclePixels(width, height, buffer);
+                // Easy case, the entire screen is being captured.
+                System.arraycopy(buffer.array(), 0, data, 0, buffer.array().length);
+                return;
             }
 
-            IntBuffer ret = IntBuffer.allocate(width * height);
             int rowStop = Math.min(y + height, scrHeight);
             int colStop = Math.min(x + width, scrWidth);
             for (int row = y; row < rowStop; row++) {
                 for (int col = x; col < colStop; col++) {
-                    ret.put(buffer.get(row * scrWidth + col));
+                    data[row * scrWidth + col] = buffer.get(row * scrWidth + col);
                 }
             }
-
-            ret.rewind();
-            return new MonoclePixels(width, height, ret);
         }
     }
 }
