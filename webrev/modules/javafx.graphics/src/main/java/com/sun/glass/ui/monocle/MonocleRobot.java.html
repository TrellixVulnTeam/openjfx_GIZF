<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>New modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/MonocleRobot.java</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2014, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 package com.sun.glass.ui.monocle;
  27 
  28 import com.sun.glass.events.MouseEvent;
  29 import com.sun.glass.ui.Application;
  30 import com.sun.glass.ui.GlassRobot;
  31 import javafx.scene.input.KeyCode;
  32 import javafx.scene.input.MouseButton;
  33 import javafx.scene.paint.Color;
  34 import javafx.scene.robot.Robot;
  35 
  36 import java.nio.ByteBuffer;
  37 import java.nio.IntBuffer;
  38 import java.nio.ShortBuffer;
  39 
  40 class MonocleRobot extends Robot {
  41     @Override
  42     public void create() {
  43         // no-op
  44     }
  45 
  46     @Override
  47     public void destroy() {
  48         // no-op
  49     }
  50 
  51     @Override
  52     public void keyPress(KeyCode code) {
  53         Application.checkEventThread();
  54         KeyState state = new KeyState();
  55         KeyInput.getInstance().getState(state);
  56         state.pressKey(code.getCode());
  57         KeyInput.getInstance().setState(state);
  58     }
  59 
  60     @Override
  61     public void keyRelease(KeyCode code) {
  62         Application.checkEventThread();
  63         KeyState state = new KeyState();
  64         KeyInput.getInstance().getState(state);
  65         state.releaseKey(code.getCode());
  66         KeyInput.getInstance().setState(state);
  67     }
  68 
  69     @Override
  70     public void mouseMove(int x, int y) {
  71         Application.checkEventThread();
  72         MouseState state = new MouseState();
  73         MouseInput.getInstance().getState(state);
  74         state.setX(x);
  75         state.setY(y);
  76         MouseInput.getInstance().setState(state, false);
  77     }
  78 
  79     private static MouseState convertToMouseState(boolean press, MouseState state, MouseButton button) {
  80         switch (button) {
  81             case PRIMARY:
  82                 if (press) {
  83                     state.pressButton(MouseEvent.BUTTON_LEFT);
  84                 } else {
  85                     state.releaseButton(MouseEvent.BUTTON_LEFT);
  86                 }
  87                 return state;
  88             case SECONDARY:
  89                 if (press) {
  90                     state.pressButton(MouseEvent.BUTTON_RIGHT);
  91                 } else {
  92                     state.releaseButton(MouseEvent.BUTTON_RIGHT);
  93                 }
  94                 return state;
  95             case MIDDLE:
  96                 if (press) {
  97                     state.pressButton(MouseEvent.BUTTON_OTHER);
  98                 } else {
  99                     state.releaseButton(MouseEvent.BUTTON_OTHER);
 100                 }
 101                 return state;
 102             default: throw new IllegalArgumentException("MouseButton: " + button +
 103                     " not supported by Monocle Robot");
 104         }
 105     }
 106 
 107     private static MouseState convertToMouseState(boolean press, MouseState state, MouseButton... buttons) {
 108         for (MouseButton button : buttons) {
 109             switch (button) {
 110                 case PRIMARY:
 111                     if (press) {
 112                         state.pressButton(MouseEvent.BUTTON_LEFT);
 113                     } else {
 114                         state.releaseButton(MouseEvent.BUTTON_LEFT);
 115                     }
 116                     break;
 117                 case SECONDARY:
 118                     if (press) {
 119                         state.pressButton(MouseEvent.BUTTON_RIGHT);
 120                     } else {
 121                         state.releaseButton(MouseEvent.BUTTON_RIGHT);
 122                     }
 123                     break;
 124                 case MIDDLE:
 125                     if (press) {
 126                         state.pressButton(MouseEvent.BUTTON_OTHER);
 127                     } else {
 128                         state.releaseButton(MouseEvent.BUTTON_OTHER);
 129                     }
 130                     break;
 131                 default: throw new IllegalArgumentException("MouseButton: " + button +
 132                         " not supported by Monocle Robot");
 133             }
 134         }
 135         return state;
 136     }
 137 
 138     @Override
 139     public void mousePress(MouseButton button) {
 140         Application.checkEventThread();
 141         MouseState state = new MouseState();
 142         MouseInput.getInstance().getState(state);
 143         MouseInput.getInstance().setState(convertToMouseState(true, state, button), false);
 144     }
 145 
 146     @Override
 147     public void mousePress(MouseButton... buttons) {
 148         Application.checkEventThread();
 149         MouseState state = new MouseState();
 150         MouseInput.getInstance().getState(state);
 151         MouseInput.getInstance().setState(convertToMouseState(true, state, buttons), false);
 152     }
 153 
 154     @Override
 155     public void mouseRelease(MouseButton button) {
 156         Application.checkEventThread();
 157         MouseState state = new MouseState();
 158         MouseInput.getInstance().getState(state);
 159         MouseInput.getInstance().setState(convertToMouseState(false, state, button), false);
 160     }
 161 
 162     @Override
 163     public void mouseRelease(MouseButton... buttons) {
 164         Application.checkEventThread();
 165         MouseState state = new MouseState();
 166         MouseInput.getInstance().getState(state);
 167         MouseInput.getInstance().setState(convertToMouseState(false, state, buttons), false);
 168     }
 169 
 170     @Override
 171     protected void mouseWheel(int wheelAmt) {
 172         Application.checkEventThread();
 173         MouseState state = new MouseState();
 174         MouseInput mouse = MouseInput.getInstance();
 175         mouse.getState(state);
 176         int direction = wheelAmt &lt; 0
 177                         ? MouseState.WHEEL_DOWN
 178                         : MouseState.WHEEL_UP;
 179         for (int i = 0; i &lt; Math.abs(wheelAmt); i++) {
 180             state.setWheel(direction);
 181             mouse.setState(state, false);
 182             state.setWheel(MouseState.WHEEL_NONE);
 183             mouse.setState(state, false);
 184         }
 185     }
 186 
 187     @Override
 188     public int getMouseX() {
 189         Application.checkEventThread();
 190         MouseState state = new MouseState();
 191         MouseInput.getInstance().getState(state);
 192         return state.getX();
 193     }
 194 
 195     @Override
 196     public int getMouseY() {
 197         Application.checkEventThread();
 198         MouseState state = new MouseState();
 199         MouseInput.getInstance().getState(state);
 200         return state.getY();
 201     }
 202 
 203     @Override
 204     public Color getPixelColor(int x, int y) {
 205         Application.checkEventThread();
 206         NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
 207         final int byteDepth = screen.getDepth() &gt;&gt;&gt; 3;
 208         final int bwidth = screen.getWidth();
 209         final int bheight = screen.getHeight();
 210 
 211         if (x &lt; 0 || x &gt; bwidth || y &lt; 0 || y &gt; bheight) {
 212             return GlassRobot.convertFromIntArgb(0);
 213         }
 214 
 215         synchronized (NativeScreen.framebufferSwapLock) {
 216 
 217             ByteBuffer buffer = screen.getScreenCapture();
 218 
 219             if (byteDepth == 2) {
 220                 ShortBuffer shortbuf = buffer.asShortBuffer();
 221 
 222                 int v = shortbuf.get((y * bwidth) + x);
 223                 int red = (v &amp; 0xF800) &gt;&gt; 11 &lt;&lt; 3;
 224                 int green = (v &amp; 0x7E0) &gt;&gt; 5 &lt;&lt; 2;
 225                 int blue = (v &amp; 0x1F) &lt;&lt; 3;
 226 
 227                 int p = (0xff000000
 228                         | (red &lt;&lt; 16)
 229                         | (green &lt;&lt; 8)
 230                         | blue);
 231                 return GlassRobot.convertFromIntArgb(p);
 232             } else if (byteDepth &gt;= 4) {
 233                 IntBuffer intbuf = buffer.asIntBuffer();
 234                 return GlassRobot.convertFromIntArgb(intbuf.get((y * bwidth) + x));
 235             } else {
 236                 throw new RuntimeException("Unknown bit depth: " + byteDepth);
 237             }
 238         }
 239     }
 240 
 241     @Override
 242     protected void getScreenCapture(int x, int y, int width, int height, int[] data) {
 243         Application.checkEventThread();
 244         NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
 245         final int scrWidth = screen.getWidth();
 246         final int scrHeight = screen.getHeight();
 247 
 248         synchronized (NativeScreen.framebufferSwapLock) {
 249             IntBuffer buffer = screen.getScreenCapture().asIntBuffer();
 250 
 251             if (x == 0 &amp;&amp; y == 0 &amp;&amp; width == scrWidth &amp;&amp; height == scrHeight) {
 252                 // Easy case, the entire screen is being captured.
 253                 System.arraycopy(buffer.array(), 0, data, 0, buffer.array().length);
 254                 return;
 255             }
 256 
 257             int rowStop = Math.min(y + height, scrHeight);
 258             int colStop = Math.min(x + width, scrWidth);
 259             for (int row = y; row &lt; rowStop; row++) {
 260                 for (int col = x; col &lt; colStop; col++) {
 261                     data[row * scrWidth + col] = buffer.get(row * scrWidth + col);
 262                 }
 263             }
 264         }
 265     }
 266 }
</pre></body></html>
