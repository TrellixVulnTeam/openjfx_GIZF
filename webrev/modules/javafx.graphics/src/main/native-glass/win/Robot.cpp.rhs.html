<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

    <script type="text/javascript" src="../../../../../../ancnav.js"></script>
    </head>
    <body id="SUNWwebrev" onkeypress="keypress(event);">
    <a name="0"></a>
    <pre>rev <a href="https://bugs.openjdk.java.net/browse/JDK-10767">10767</a> : Move Robot to public API.</pre><hr></hr>
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include "common.h"
  27 #include "math.h"
  28 
  29 #include "KeyTable.h"
  30 
<a name="1" id="anc1"></a>
  31 #include "com_sun_glass_ui_win_WinRobot.h"
  32 #include "GlassScreen.h"
  33 
  34 
  35 static BOOL KeyEvent(JNIEnv *env, int code, bool isPress) {
  36     UINT vkey, modifiers;
  37 
  38     JavaKeyToWindowsKey(code, vkey, modifiers);
  39 
  40     if (!vkey) {
  41         return FALSE;
  42     } else {
  43         UINT scancode = ::MapVirtualKey(vkey, 0);
  44 
  45         INPUT keyInput = {0};
  46         keyInput.type = INPUT_KEYBOARD;
  47         keyInput.ki.wVk = vkey;
  48         keyInput.ki.wScan = scancode;
  49         keyInput.ki.time = 0;
  50         keyInput.ki.dwExtraInfo = 0;
  51         keyInput.ki.dwFlags = isPress ?  0 : KEYEVENTF_KEYUP;
  52         if (IsExtendedKey(vkey)) {
  53             keyInput.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
  54         }
  55 
  56         ::SendInput(1, &amp;keyInput, sizeof(keyInput));
  57 
  58         return TRUE;
  59     }
  60 }
  61 
  62 inline static jint WinToJavaPixel(USHORT r, USHORT g, USHORT b)
  63 {
  64     jint value =
  65             0xFF &lt;&lt; 24 | // alpha channel is always turned all the way up
  66             r &lt;&lt; 16 |
  67             g &lt;&lt; 8  |
  68             b &lt;&lt; 0;
  69     return value;
  70 }
  71 
  72 extern "C" {
  73 
  74 /*
  75  * Class:     com_sun_glass_ui_win_WinRobot
  76  * Method:    _keyPress
  77  * Signature: (I)V
  78  */
  79 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1keyPress
  80     (JNIEnv *env, jobject jrobot, jint code)
  81 {
  82     KeyEvent(env, code, true);
  83 }
  84 
  85 /*
  86  * Class:     com_sun_glass_ui_win_WinRobot
  87  * Method:    _keyRelease
  88  * Signature: (I)V
  89  */
  90 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1keyRelease
  91     (JNIEnv *env, jobject jrobot, jint code)
  92 {
  93     KeyEvent(env, code, false);
  94 }
  95 
  96 /*
  97  * Class:     com_sun_glass_ui_win_WinRobot
  98  * Method:    _mouseMove
  99  * Signature: (II)V
 100  */
 101 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1mouseMove
 102     (JNIEnv *env, jobject jrobot, jint x, jint y)
 103 {
 104     int oldAccel[3], newAccel[3];
 105     INT_PTR oldSpeed, newSpeed;
 106     BOOL bResult;
 107 
 108     jfloat fx = (jfloat) x + 0.5f;
 109     jfloat fy = (jfloat) y + 0.5f;
 110     GlassScreen::FX2Win(&amp;fx, &amp;fy);
 111     x = (jint) fx;
 112     y = (jint) fy;
 113 
 114     // The following values set mouse ballistics to 1 mickey/pixel.
 115     newAccel[0] = 0;
 116     newAccel[1] = 0;
 117     newAccel[2] = 0;
 118     newSpeed = 10;
 119 
 120     // Save the Current Mouse Acceleration Constants
 121     bResult = ::SystemParametersInfo(SPI_GETMOUSE, 0, oldAccel, 0);
 122     bResult = ::SystemParametersInfo(SPI_GETMOUSESPEED, 0, &amp;oldSpeed, 0);
 123     // Set the new Mouse Acceleration Constants (Disabled).
 124     bResult = ::SystemParametersInfo(SPI_SETMOUSE, 0, newAccel, SPIF_SENDCHANGE);
 125     bResult = ::SystemParametersInfo(SPI_SETMOUSESPEED, 0,
 126             (PVOID)newSpeed,
 127             SPIF_SENDCHANGE);
 128 
 129     POINT curPos;
 130     ::GetCursorPos(&amp;curPos);
 131     x -= curPos.x;
 132     y -= curPos.y;
 133 
 134     ::mouse_event(MOUSEEVENTF_MOVE, x, y, 0, 0);
 135     // Move the cursor to the desired coordinates.
 136 
 137     // Restore the old Mouse Acceleration Constants.
 138     bResult = ::SystemParametersInfo(SPI_SETMOUSE,0, oldAccel, SPIF_SENDCHANGE);
 139     bResult = ::SystemParametersInfo(SPI_SETMOUSESPEED, 0, (PVOID)oldSpeed,
 140             SPIF_SENDCHANGE);
 141 }
 142 
 143 /*
 144  * Class:     com_sun_glass_ui_win_WinRobot
 145  * Method:    _getMouseX
 146  * Signature: ()I
 147  */
 148 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_win_WinRobot__1getMouseX
 149     (JNIEnv *env, jobject jrobot)
 150 {
 151     POINT curPos;
 152     ::GetCursorPos(&amp;curPos);
 153     jfloat fx = (jfloat) curPos.x + 0.5f;
 154     jfloat fy = (jfloat) curPos.y + 0.5f;
 155     GlassScreen::Win2FX(&amp;fx, &amp;fy);
 156     return (jint) fx;
 157 }
 158 
 159 /*
 160  * Class:     com_sun_glass_ui_win_WinRobot
 161  * Method:    _getMouseY
 162  * Signature: ()I
 163  */
 164 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_win_WinRobot__1getMouseY
 165     (JNIEnv *env, jobject jrobot)
 166 {
 167     POINT curPos;
 168     ::GetCursorPos(&amp;curPos);
 169     jfloat fx = (jfloat) curPos.x + 0.5f;
 170     jfloat fy = (jfloat) curPos.y + 0.5f;
 171     GlassScreen::Win2FX(&amp;fx, &amp;fy);
 172     return (jint) fy;
 173 }
 174 
 175 /*
 176  * Class:     com_sun_glass_ui_win_WinRobot
 177  * Method:    _mousePress
 178  * Signature: (I)V
 179  */
 180 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1mousePress
 181     (JNIEnv *env, jobject jrobot, jint buttons)
 182 {
 183     DWORD dwFlags = 0L;
 184     // According to MSDN: Software Driving Software
 185     // application should consider SM_SWAPBUTTON to correctly emulate user with
 186     // left handed mouse setup
 187     BOOL bSwap = ::GetSystemMetrics(SM_SWAPBUTTON);
 188 
 189     if (buttons &amp; (1 &lt;&lt; 0)) {
 190         dwFlags |= !bSwap ? MOUSEEVENTF_LEFTDOWN : MOUSEEVENTF_RIGHTDOWN;
 191     }
 192     if (buttons &amp; (1 &lt;&lt; 1)) {
 193         dwFlags |= !bSwap ? MOUSEEVENTF_RIGHTDOWN : MOUSEEVENTF_LEFTDOWN;
 194     }
 195     if (buttons &amp; (1 &lt;&lt; 2)) {
 196         dwFlags |= MOUSEEVENTF_MIDDLEDOWN;
 197     }
 198 
 199     INPUT mouseInput = {0};
 200     mouseInput.type = INPUT_MOUSE;
 201     mouseInput.mi.time = 0;
 202     mouseInput.mi.dwFlags = dwFlags;
 203 
 204     // Support for extra buttons
 205     if (buttons &amp; (1 &lt;&lt; 3)) {
 206         mouseInput.mi.dwFlags |= MOUSEEVENTF_XDOWN;
 207         mouseInput.mi.mouseData = XBUTTON1;
 208     }
 209     if (buttons &amp; (1 &lt;&lt; 4)) {
 210         mouseInput.mi.dwFlags |= MOUSEEVENTF_XDOWN;
 211         mouseInput.mi.mouseData = XBUTTON2;
 212     }
 213 
 214     ::SendInput(1, &amp;mouseInput, sizeof(mouseInput));
 215 }
 216 
 217 /*
 218  * Class:     com_sun_glass_ui_win_WinRobot
 219  * Method:    _mouseRelease
 220  * Signature: (I)V
 221  */
 222 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1mouseRelease
 223     (JNIEnv *env, jobject jrobot, jint buttons)
 224 {
 225     DWORD dwFlags = 0L;
 226     // According to MSDN: Software Driving Software
 227     // application should consider SM_SWAPBUTTON to correctly emulate user with
 228     // left handed mouse setup
 229     BOOL bSwap = ::GetSystemMetrics(SM_SWAPBUTTON);
 230 
 231     if (buttons &amp; (1 &lt;&lt; 0)) {
 232         dwFlags |= !bSwap ? MOUSEEVENTF_LEFTUP : MOUSEEVENTF_RIGHTUP;
 233     }
 234     if (buttons &amp; (1 &lt;&lt; 1)) {
 235         dwFlags |= !bSwap ? MOUSEEVENTF_RIGHTUP : MOUSEEVENTF_LEFTUP;
 236     }
 237     if (buttons &amp; (1 &lt;&lt; 2)) {
 238         dwFlags |= MOUSEEVENTF_MIDDLEUP;
 239     }
 240 
 241     INPUT mouseInput = {0};
 242     mouseInput.type = INPUT_MOUSE;
 243     mouseInput.mi.time = 0;
 244     mouseInput.mi.dwFlags = dwFlags;
 245 
 246     // Support for extra buttons
 247     if (buttons &amp; (1 &lt;&lt; 3)) {
 248         mouseInput.mi.dwFlags |= MOUSEEVENTF_XUP;
 249         mouseInput.mi.mouseData = XBUTTON1;
 250     }
 251     if (buttons &amp; (1 &lt;&lt; 4)) {
 252         mouseInput.mi.dwFlags |= MOUSEEVENTF_XUP;
 253         mouseInput.mi.mouseData = XBUTTON2;
 254     }
 255 
 256     ::SendInput(1, &amp;mouseInput, sizeof(mouseInput));
 257 }
 258 
 259 /*
 260  * Class:     com_sun_glass_ui_win_WinRobot
 261  * Method:    _mouseWheel
 262  * Signature: (I)V
 263  */
 264 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1mouseWheel
 265     (JNIEnv *env, jobject jrobot, jint wheelAmt)
 266 {
 267     ::mouse_event(MOUSEEVENTF_WHEEL, 0, 0, wheelAmt * -1 * WHEEL_DELTA, 0);
 268 }
 269 
 270 void GetScreenCapture(jint x, jint y, jint devw, jint devh,
 271                       jint *pixelData, jint retw, jint reth);
 272 
 273 /*
 274  * Class:     com_sun_glass_ui_win_WinRobot
 275  * Method:    _getPixelColor
 276  * Signature: (II)I
 277  */
 278 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_win_WinRobot__1getPixelColor
 279     (JNIEnv *env, jobject jrobot, jint x, jint y)
 280 {
 281     jfloat fx = (jfloat) x + 0.5f;
 282     jfloat fy = (jfloat) y + 0.5f;
 283     GlassScreen::FX2Win(&amp;fx, &amp;fy);
 284     jint dx = (jint) fx;
 285     jint dy = (jint) fy;
 286 
 287     jint val = 0;
 288     //NOTE: we don't use the ::GetPixel() on the screen DC because it's not capable of
 289     //      getting the correct colors when non-opaque windows are present
 290     GetScreenCapture(dx, dy, 1, 1, &amp;val, 1, 1);
 291     return val;
 292 }
 293 
 294 /*
 295  * Class:     com_sun_glass_ui_win_WinRobot
<a name="2" id="anc2"></a><span class="changed"> 296  * Method:    getScreenCapture</span>
 297  * Signature: (IIII[I;)V
 298  */
<a name="3" id="anc3"></a><span class="changed"> 299 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot_getScreenCapture</span>
 300     (JNIEnv *env, jobject jrobot, jint x, jint y, jint width, jint height, jintArray pixelArray)
 301 {
 302     int numPixels = width * height;
 303     int pixelDataSize = sizeof(jint) * numPixels;
 304     ASSERT(pixelDataSize &gt; 0 &amp;&amp; pixelDataSize % 4 == 0);
 305 
 306     jint * pixelData = (jint *)(new BYTE[pixelDataSize]);
 307 
 308     if (pixelData) {
 309         GetScreenCapture(x, y, width, height, pixelData, width, height);
 310 
 311         // copy pixels into Java array
 312         env-&gt;SetIntArrayRegion(pixelArray, 0, numPixels, pixelData);
 313         delete pixelData;
 314     }
 315 }
 316 
 317 void GetScreenCapture(jint x, jint y, jint devw, jint devh,
 318                       jint *pixelData, jint retw, jint reth)
 319 {
 320     HDC hdcScreen = ::CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
 321     HDC hdcMem = ::CreateCompatibleDC(hdcScreen);
 322     HBITMAP hbitmap;
 323     HBITMAP hOldBitmap;
 324     HPALETTE hOldPalette = NULL;
 325 
 326     // create an offscreen bitmap
 327     hbitmap = ::CreateCompatibleBitmap(hdcScreen, retw, reth);
 328     if (hbitmap == NULL) {
 329         //TODO: OOM might be better?
 330         //throw std::bad_alloc();
 331     }
 332     hOldBitmap = (HBITMAP)::SelectObject(hdcMem, hbitmap);
 333 
 334     /* TODO: check this out
 335     // REMIND: not multimon-friendly...
 336     int primaryIndex = AwtWin32GraphicsDevice::GetDefaultDeviceIndex();
 337     hOldPalette =
 338         AwtWin32GraphicsDevice::SelectPalette(hdcMem, primaryIndex);
 339     AwtWin32GraphicsDevice::RealizePalette(hdcMem, primaryIndex);
 340     */
 341 
 342     // copy screen image to offscreen bitmap
 343     // CAPTUREBLT flag is required to capture WS_EX_LAYERED windows' contents
 344     // correctly on Win2K/XP
 345     static const DWORD dwRop = SRCCOPY|CAPTUREBLT;
 346     if (retw == devw &amp;&amp; reth == devh) {
 347         ::BitBlt(hdcMem, 0, 0, retw, reth, hdcScreen, x, y, dwRop);
 348     } else {
 349         ::StretchBlt(hdcMem, 0, 0, retw, reth, hdcScreen, x, y, devw, devh, dwRop);
 350     }
 351 
 352     static const int BITS_PER_PIXEL = 32;
 353 
 354     struct {
 355         BITMAPINFOHEADER bmiHeader;
 356         RGBQUAD          bmiColors[3];
 357     } BitmapInfo;
 358 
 359     // prepare BITMAPINFO for a 32-bit RGB bitmap
 360     ::memset(&amp;BitmapInfo, 0, sizeof(BitmapInfo));
 361     BitmapInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
 362     BitmapInfo.bmiHeader.biWidth = retw;
 363     BitmapInfo.bmiHeader.biHeight = -reth; // negative height means a top-down DIB
 364     BitmapInfo.bmiHeader.biPlanes = 1;
 365     BitmapInfo.bmiHeader.biBitCount = BITS_PER_PIXEL;
 366     BitmapInfo.bmiHeader.biCompression = BI_BITFIELDS;
 367 
 368     // Setup up color masks
 369     static const RGBQUAD redMask =   {0, 0, 0xFF, 0};
 370     static const RGBQUAD greenMask = {0, 0xFF, 0, 0};
 371     static const RGBQUAD blueMask =  {0xFF, 0, 0, 0};
 372 
 373     BitmapInfo.bmiColors[0] = redMask;
 374     BitmapInfo.bmiColors[1] = greenMask;
 375     BitmapInfo.bmiColors[2] = blueMask;
 376 
 377     // Get the bitmap data in device-independent, 32-bit packed pixel format
 378     ::GetDIBits(hdcMem, hbitmap, 0, reth, pixelData, (BITMAPINFO *)&amp;BitmapInfo, DIB_RGB_COLORS);
 379 
 380     // convert Win32 pixel format (BGRX) to Java format (ARGB)
 381     ASSERT(sizeof(jint) == sizeof(RGBQUAD));
 382     jint numPixels = retw * reth;
 383     jint *pPixel = pixelData;
 384     for(int nPixel = 0; nPixel &lt; numPixels; nPixel++) {
 385         RGBQUAD * prgbq = (RGBQUAD *) pPixel;
 386         *pPixel++ = WinToJavaPixel(prgbq-&gt;rgbRed, prgbq-&gt;rgbGreen, prgbq-&gt;rgbBlue);
 387     }
 388 
 389     // free all the GDI objects we made
 390     ::SelectObject(hdcMem, hOldBitmap);
 391     if (hOldPalette != NULL) {
 392         ::SelectPalette(hdcMem, hOldPalette, FALSE);
 393     }
 394     ::DeleteObject(hbitmap);
 395     ::DeleteDC(hdcMem);
 396     ::DeleteDC(hdcScreen);
 397 }
 398 
 399 }
 400 
<a name="4" id="anc4"></a><b style="font-size: large; color: red">--- EOF ---</b>















































































</pre><form name="eof"><input name="value" value="4" type="hidden" /></form></body></html>
