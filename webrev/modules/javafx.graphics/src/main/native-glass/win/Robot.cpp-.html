<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head><meta charset="utf-8">
<meta http-equiv="cache-control" content="no-cache" />
<meta http-equiv="Pragma" content="no-cache" />
<meta http-equiv="Expires" content="-1" />
<!--
   Note to customizers: the body of the webrev is IDed as SUNWwebrev
   to allow easy overriding by users of webrev via the userContent.css
   mechanism available in some browsers.

   For example, to have all "removed" information be red instead of
   brown, set a rule in your userContent.css file like:

       body#SUNWwebrev span.removed { color: red ! important; }
-->
<style type="text/css" media="screen">
body {
    background-color: #eeeeee;
}
hr {
    border: none 0;
    border-top: 1px solid #aaa;
    height: 1px;
}
div.summary {
    font-size: .8em;
    border-bottom: 1px solid #aaa;
    padding-left: 1em;
    padding-right: 1em;
}
div.summary h2 {
    margin-bottom: 0.3em;
}
div.summary table th {
    text-align: right;
    vertical-align: top;
    white-space: nowrap;
}
span.lineschanged {
    font-size: 0.7em;
}
span.oldmarker {
    color: red;
    font-size: large;
    font-weight: bold;
}
span.newmarker {
    color: green;
    font-size: large;
    font-weight: bold;
}
span.removed {
    color: brown;
}
span.changed {
    color: blue;
}
span.new {
    color: blue;
    font-weight: bold;
}
a.print { font-size: x-small; }

</style>

<style type="text/css" media="print">
pre { font-size: 0.8em; font-family: courier, monospace; }
span.removed { color: #444; font-style: italic }
span.changed { font-weight: bold; }
span.new { font-weight: bold; }
span.newmarker { font-size: 1.2em; font-weight: bold; }
span.oldmarker { font-size: 1.2em; font-weight: bold; }
a.print {display: none}
hr { border: none 0; border-top: 1px solid #aaa; height: 1px; }
</style>

<title>Old modules/javafx.graphics/src/main/native-glass/win/Robot.cpp</title>
<body id="SUNWwebrev">
<pre>
   1 /*
   2  * Copyright (c) 2011, 2016, Oracle and/or its affiliates. All rights reserved.
   3  * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
   4  *
   5  * This code is free software; you can redistribute it and/or modify it
   6  * under the terms of the GNU General Public License version 2 only, as
   7  * published by the Free Software Foundation.  Oracle designates this
   8  * particular file as subject to the "Classpath" exception as provided
   9  * by Oracle in the LICENSE file that accompanied this code.
  10  *
  11  * This code is distributed in the hope that it will be useful, but WITHOUT
  12  * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
  13  * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
  14  * version 2 for more details (a copy is included in the LICENSE file that
  15  * accompanied this code).
  16  *
  17  * You should have received a copy of the GNU General Public License version
  18  * 2 along with this work; if not, write to the Free Software Foundation,
  19  * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
  20  *
  21  * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
  22  * or visit www.oracle.com if you need additional information or have any
  23  * questions.
  24  */
  25 
  26 #include "common.h"
  27 #include "math.h"
  28 
  29 #include "KeyTable.h"
  30 
  31 #include "com_sun_glass_ui_Robot.h"
  32 #include "com_sun_glass_ui_win_WinRobot.h"
  33 #include "GlassScreen.h"
  34 
  35 
  36 static BOOL KeyEvent(JNIEnv *env, int code, bool isPress) {
  37     UINT vkey, modifiers;
  38 
  39     JavaKeyToWindowsKey(code, vkey, modifiers);
  40 
  41     if (!vkey) {
  42         return FALSE;
  43     } else {
  44         UINT scancode = ::MapVirtualKey(vkey, 0);
  45 
  46         INPUT keyInput = {0};
  47         keyInput.type = INPUT_KEYBOARD;
  48         keyInput.ki.wVk = vkey;
  49         keyInput.ki.wScan = scancode;
  50         keyInput.ki.time = 0;
  51         keyInput.ki.dwExtraInfo = 0;
  52         keyInput.ki.dwFlags = isPress ?  0 : KEYEVENTF_KEYUP;
  53         if (IsExtendedKey(vkey)) {
  54             keyInput.ki.dwFlags |= KEYEVENTF_EXTENDEDKEY;
  55         }
  56 
  57         ::SendInput(1, &amp;keyInput, sizeof(keyInput));
  58 
  59         return TRUE;
  60     }
  61 }
  62 
  63 inline static jint WinToJavaPixel(USHORT r, USHORT g, USHORT b)
  64 {
  65     jint value =
  66             0xFF &lt;&lt; 24 | // alpha channel is always turned all the way up
  67             r &lt;&lt; 16 |
  68             g &lt;&lt; 8  |
  69             b &lt;&lt; 0;
  70     return value;
  71 }
  72 
  73 extern "C" {
  74 
  75 /*
  76  * Class:     com_sun_glass_ui_win_WinRobot
  77  * Method:    _keyPress
  78  * Signature: (I)V
  79  */
  80 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1keyPress
  81     (JNIEnv *env, jobject jrobot, jint code)
  82 {
  83     KeyEvent(env, code, true);
  84 }
  85 
  86 /*
  87  * Class:     com_sun_glass_ui_win_WinRobot
  88  * Method:    _keyRelease
  89  * Signature: (I)V
  90  */
  91 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1keyRelease
  92     (JNIEnv *env, jobject jrobot, jint code)
  93 {
  94     KeyEvent(env, code, false);
  95 }
  96 
  97 /*
  98  * Class:     com_sun_glass_ui_win_WinRobot
  99  * Method:    _mouseMove
 100  * Signature: (II)V
 101  */
 102 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1mouseMove
 103     (JNIEnv *env, jobject jrobot, jint x, jint y)
 104 {
 105     int oldAccel[3], newAccel[3];
 106     INT_PTR oldSpeed, newSpeed;
 107     BOOL bResult;
 108 
 109     jfloat fx = (jfloat) x + 0.5f;
 110     jfloat fy = (jfloat) y + 0.5f;
 111     GlassScreen::FX2Win(&amp;fx, &amp;fy);
 112     x = (jint) fx;
 113     y = (jint) fy;
 114 
 115     // The following values set mouse ballistics to 1 mickey/pixel.
 116     newAccel[0] = 0;
 117     newAccel[1] = 0;
 118     newAccel[2] = 0;
 119     newSpeed = 10;
 120 
 121     // Save the Current Mouse Acceleration Constants
 122     bResult = ::SystemParametersInfo(SPI_GETMOUSE, 0, oldAccel, 0);
 123     bResult = ::SystemParametersInfo(SPI_GETMOUSESPEED, 0, &amp;oldSpeed, 0);
 124     // Set the new Mouse Acceleration Constants (Disabled).
 125     bResult = ::SystemParametersInfo(SPI_SETMOUSE, 0, newAccel, SPIF_SENDCHANGE);
 126     bResult = ::SystemParametersInfo(SPI_SETMOUSESPEED, 0,
 127             (PVOID)newSpeed,
 128             SPIF_SENDCHANGE);
 129 
 130     POINT curPos;
 131     ::GetCursorPos(&amp;curPos);
 132     x -= curPos.x;
 133     y -= curPos.y;
 134 
 135     ::mouse_event(MOUSEEVENTF_MOVE, x, y, 0, 0);
 136     // Move the cursor to the desired coordinates.
 137 
 138     // Restore the old Mouse Acceleration Constants.
 139     bResult = ::SystemParametersInfo(SPI_SETMOUSE,0, oldAccel, SPIF_SENDCHANGE);
 140     bResult = ::SystemParametersInfo(SPI_SETMOUSESPEED, 0, (PVOID)oldSpeed,
 141             SPIF_SENDCHANGE);
 142 }
 143 
 144 /*
 145  * Class:     com_sun_glass_ui_win_WinRobot
 146  * Method:    _getMouseX
 147  * Signature: ()I
 148  */
 149 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_win_WinRobot__1getMouseX
 150     (JNIEnv *env, jobject jrobot)
 151 {
 152     POINT curPos;
 153     ::GetCursorPos(&amp;curPos);
 154     jfloat fx = (jfloat) curPos.x + 0.5f;
 155     jfloat fy = (jfloat) curPos.y + 0.5f;
 156     GlassScreen::Win2FX(&amp;fx, &amp;fy);
 157     return (jint) fx;
 158 }
 159 
 160 /*
 161  * Class:     com_sun_glass_ui_win_WinRobot
 162  * Method:    _getMouseY
 163  * Signature: ()I
 164  */
 165 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_win_WinRobot__1getMouseY
 166     (JNIEnv *env, jobject jrobot)
 167 {
 168     POINT curPos;
 169     ::GetCursorPos(&amp;curPos);
 170     jfloat fx = (jfloat) curPos.x + 0.5f;
 171     jfloat fy = (jfloat) curPos.y + 0.5f;
 172     GlassScreen::Win2FX(&amp;fx, &amp;fy);
 173     return (jint) fy;
 174 }
 175 
 176 /*
 177  * Class:     com_sun_glass_ui_win_WinRobot
 178  * Method:    _mousePress
 179  * Signature: (I)V
 180  */
 181 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1mousePress
 182     (JNIEnv *env, jobject jrobot, jint buttons)
 183 {
 184     DWORD dwFlags = 0L;
 185     // According to MSDN: Software Driving Software
 186     // application should consider SM_SWAPBUTTON to correctly emulate user with
 187     // left handed mouse setup
 188     BOOL bSwap = ::GetSystemMetrics(SM_SWAPBUTTON);
 189 
 190     if (buttons &amp; (1 &lt;&lt; 0)) {
 191         dwFlags |= !bSwap ? MOUSEEVENTF_LEFTDOWN : MOUSEEVENTF_RIGHTDOWN;
 192     }
 193     if (buttons &amp; (1 &lt;&lt; 1)) {
 194         dwFlags |= !bSwap ? MOUSEEVENTF_RIGHTDOWN : MOUSEEVENTF_LEFTDOWN;
 195     }
 196     if (buttons &amp; (1 &lt;&lt; 2)) {
 197         dwFlags |= MOUSEEVENTF_MIDDLEDOWN;
 198     }
 199 
 200     INPUT mouseInput = {0};
 201     mouseInput.type = INPUT_MOUSE;
 202     mouseInput.mi.time = 0;
 203     mouseInput.mi.dwFlags = dwFlags;
 204 
 205     // Support for extra buttons
 206     if (buttons &amp; (1 &lt;&lt; 3)) {
 207         mouseInput.mi.dwFlags |= MOUSEEVENTF_XDOWN;
 208         mouseInput.mi.mouseData = XBUTTON1;
 209     }
 210     if (buttons &amp; (1 &lt;&lt; 4)) {
 211         mouseInput.mi.dwFlags |= MOUSEEVENTF_XDOWN;
 212         mouseInput.mi.mouseData = XBUTTON2;
 213     }
 214 
 215     ::SendInput(1, &amp;mouseInput, sizeof(mouseInput));
 216 }
 217 
 218 /*
 219  * Class:     com_sun_glass_ui_win_WinRobot
 220  * Method:    _mouseRelease
 221  * Signature: (I)V
 222  */
 223 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1mouseRelease
 224     (JNIEnv *env, jobject jrobot, jint buttons)
 225 {
 226     DWORD dwFlags = 0L;
 227     // According to MSDN: Software Driving Software
 228     // application should consider SM_SWAPBUTTON to correctly emulate user with
 229     // left handed mouse setup
 230     BOOL bSwap = ::GetSystemMetrics(SM_SWAPBUTTON);
 231 
 232     if (buttons &amp; (1 &lt;&lt; 0)) {
 233         dwFlags |= !bSwap ? MOUSEEVENTF_LEFTUP : MOUSEEVENTF_RIGHTUP;
 234     }
 235     if (buttons &amp; (1 &lt;&lt; 1)) {
 236         dwFlags |= !bSwap ? MOUSEEVENTF_RIGHTUP : MOUSEEVENTF_LEFTUP;
 237     }
 238     if (buttons &amp; (1 &lt;&lt; 2)) {
 239         dwFlags |= MOUSEEVENTF_MIDDLEUP;
 240     }
 241 
 242     INPUT mouseInput = {0};
 243     mouseInput.type = INPUT_MOUSE;
 244     mouseInput.mi.time = 0;
 245     mouseInput.mi.dwFlags = dwFlags;
 246 
 247     // Support for extra buttons
 248     if (buttons &amp; (1 &lt;&lt; 3)) {
 249         mouseInput.mi.dwFlags |= MOUSEEVENTF_XUP;
 250         mouseInput.mi.mouseData = XBUTTON1;
 251     }
 252     if (buttons &amp; (1 &lt;&lt; 4)) {
 253         mouseInput.mi.dwFlags |= MOUSEEVENTF_XUP;
 254         mouseInput.mi.mouseData = XBUTTON2;
 255     }
 256 
 257     ::SendInput(1, &amp;mouseInput, sizeof(mouseInput));
 258 }
 259 
 260 /*
 261  * Class:     com_sun_glass_ui_win_WinRobot
 262  * Method:    _mouseWheel
 263  * Signature: (I)V
 264  */
 265 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1mouseWheel
 266     (JNIEnv *env, jobject jrobot, jint wheelAmt)
 267 {
 268     ::mouse_event(MOUSEEVENTF_WHEEL, 0, 0, wheelAmt * -1 * WHEEL_DELTA, 0);
 269 }
 270 
 271 void GetScreenCapture(jint x, jint y, jint devw, jint devh,
 272                       jint *pixelData, jint retw, jint reth);
 273 
 274 /*
 275  * Class:     com_sun_glass_ui_win_WinRobot
 276  * Method:    _getPixelColor
 277  * Signature: (II)I
 278  */
 279 JNIEXPORT jint JNICALL Java_com_sun_glass_ui_win_WinRobot__1getPixelColor
 280     (JNIEnv *env, jobject jrobot, jint x, jint y)
 281 {
 282     jfloat fx = (jfloat) x + 0.5f;
 283     jfloat fy = (jfloat) y + 0.5f;
 284     GlassScreen::FX2Win(&amp;fx, &amp;fy);
 285     jint dx = (jint) fx;
 286     jint dy = (jint) fy;
 287 
 288     jint val = 0;
 289     //NOTE: we don't use the ::GetPixel() on the screen DC because it's not capable of
 290     //      getting the correct colors when non-opaque windows are present
 291     GetScreenCapture(dx, dy, 1, 1, &amp;val, 1, 1);
 292     return val;
 293 }
 294 
 295 /*
 296  * Class:     com_sun_glass_ui_win_WinRobot
 297  * Method:    _getScreenCapture
 298  * Signature: (IIII[I;)V
 299  */
 300 JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1getScreenCapture
 301     (JNIEnv *env, jobject jrobot, jint x, jint y, jint width, jint height, jintArray pixelArray)
 302 {
 303     int numPixels = width * height;
 304     int pixelDataSize = sizeof(jint) * numPixels;
 305     ASSERT(pixelDataSize &gt; 0 &amp;&amp; pixelDataSize % 4 == 0);
 306 
 307     jint * pixelData = (jint *)(new BYTE[pixelDataSize]);
 308 
 309     if (pixelData) {
 310         GetScreenCapture(x, y, width, height, pixelData, width, height);
 311 
 312         // copy pixels into Java array
 313         env-&gt;SetIntArrayRegion(pixelArray, 0, numPixels, pixelData);
 314         delete pixelData;
 315     }
 316 }
 317 
 318 void GetScreenCapture(jint x, jint y, jint devw, jint devh,
 319                       jint *pixelData, jint retw, jint reth)
 320 {
 321     HDC hdcScreen = ::CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
 322     HDC hdcMem = ::CreateCompatibleDC(hdcScreen);
 323     HBITMAP hbitmap;
 324     HBITMAP hOldBitmap;
 325     HPALETTE hOldPalette = NULL;
 326 
 327     // create an offscreen bitmap
 328     hbitmap = ::CreateCompatibleBitmap(hdcScreen, retw, reth);
 329     if (hbitmap == NULL) {
 330         //TODO: OOM might be better?
 331         //throw std::bad_alloc();
 332     }
 333     hOldBitmap = (HBITMAP)::SelectObject(hdcMem, hbitmap);
 334 
 335     /* TODO: check this out
 336     // REMIND: not multimon-friendly...
 337     int primaryIndex = AwtWin32GraphicsDevice::GetDefaultDeviceIndex();
 338     hOldPalette =
 339         AwtWin32GraphicsDevice::SelectPalette(hdcMem, primaryIndex);
 340     AwtWin32GraphicsDevice::RealizePalette(hdcMem, primaryIndex);
 341     */
 342 
 343     // copy screen image to offscreen bitmap
 344     // CAPTUREBLT flag is required to capture WS_EX_LAYERED windows' contents
 345     // correctly on Win2K/XP
 346     static const DWORD dwRop = SRCCOPY|CAPTUREBLT;
 347     if (retw == devw &amp;&amp; reth == devh) {
 348         ::BitBlt(hdcMem, 0, 0, retw, reth, hdcScreen, x, y, dwRop);
 349     } else {
 350         ::StretchBlt(hdcMem, 0, 0, retw, reth, hdcScreen, x, y, devw, devh, dwRop);
 351     }
 352 
 353     static const int BITS_PER_PIXEL = 32;
 354 
 355     struct {
 356         BITMAPINFOHEADER bmiHeader;
 357         RGBQUAD          bmiColors[3];
 358     } BitmapInfo;
 359 
 360     // prepare BITMAPINFO for a 32-bit RGB bitmap
 361     ::memset(&amp;BitmapInfo, 0, sizeof(BitmapInfo));
 362     BitmapInfo.bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
 363     BitmapInfo.bmiHeader.biWidth = retw;
 364     BitmapInfo.bmiHeader.biHeight = -reth; // negative height means a top-down DIB
 365     BitmapInfo.bmiHeader.biPlanes = 1;
 366     BitmapInfo.bmiHeader.biBitCount = BITS_PER_PIXEL;
 367     BitmapInfo.bmiHeader.biCompression = BI_BITFIELDS;
 368 
 369     // Setup up color masks
 370     static const RGBQUAD redMask =   {0, 0, 0xFF, 0};
 371     static const RGBQUAD greenMask = {0, 0xFF, 0, 0};
 372     static const RGBQUAD blueMask =  {0xFF, 0, 0, 0};
 373 
 374     BitmapInfo.bmiColors[0] = redMask;
 375     BitmapInfo.bmiColors[1] = greenMask;
 376     BitmapInfo.bmiColors[2] = blueMask;
 377 
 378     // Get the bitmap data in device-independent, 32-bit packed pixel format
 379     ::GetDIBits(hdcMem, hbitmap, 0, reth, pixelData, (BITMAPINFO *)&amp;BitmapInfo, DIB_RGB_COLORS);
 380 
 381     // convert Win32 pixel format (BGRX) to Java format (ARGB)
 382     ASSERT(sizeof(jint) == sizeof(RGBQUAD));
 383     jint numPixels = retw * reth;
 384     jint *pPixel = pixelData;
 385     for(int nPixel = 0; nPixel &lt; numPixels; nPixel++) {
 386         RGBQUAD * prgbq = (RGBQUAD *) pPixel;
 387         *pPixel++ = WinToJavaPixel(prgbq-&gt;rgbRed, prgbq-&gt;rgbGreen, prgbq-&gt;rgbBlue);
 388     }
 389 
 390     // free all the GDI objects we made
 391     ::SelectObject(hdcMem, hOldBitmap);
 392     if (hOldPalette != NULL) {
 393         ::SelectPalette(hdcMem, hOldPalette, FALSE);
 394     }
 395     ::DeleteObject(hbitmap);
 396     ::DeleteDC(hdcMem);
 397     ::DeleteDC(hdcScreen);
 398 }
 399 
 400 }
 401 
</pre></body></html>
