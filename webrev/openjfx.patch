--- old/apps/tests/HelloTest/src/hellotest/RemoveFocusedControl.java	2018-01-01 14:51:03.695616500 -0700
+++ new/apps/tests/HelloTest/src/hellotest/RemoveFocusedControl.java	2018-01-01 14:51:03.314594700 -0700
@@ -30,9 +30,9 @@
 import javafx.scene.Group;
 import javafx.scene.Scene;
 import javafx.scene.control.Button;
+import javafx.scene.input.KeyEvent;
+import javafx.scene.robot.Robot;
 import javafx.stage.Stage;
-import com.sun.glass.events.KeyEvent;
-import com.sun.glass.ui.Robot;
 
 public class RemoveFocusedControl extends Application {
 
@@ -62,14 +62,14 @@
 
         button1.setOnAction((ActionEvent e) -> {
             root.getChildren().remove(button1);
-            robot.keyPress(KeyEvent.VK_T);
-            robot.keyRelease(KeyEvent.VK_T);
-            robot.keyPress(KeyEvent.VK_E);
-            robot.keyRelease(KeyEvent.VK_E);
-            robot.keyPress(KeyEvent.VK_S);
-            robot.keyRelease(KeyEvent.VK_S);
-            robot.keyPress(KeyEvent.VK_T);
-            robot.keyRelease(KeyEvent.VK_T);
+            robot.keyPress(KeyCode.T);
+            robot.keyRelease(KeyCode.T);
+            robot.keyPress(KeyCode.E);
+            robot.keyRelease(KeyCode.E);
+            robot.keyPress(KeyCode.S);
+            robot.keyRelease(KeyCode.S);
+            robot.keyPress(KeyCode.T);
+            robot.keyRelease(KeyCode.T);
         });
 
         root.getChildren().add(button1);
--- old/apps/tests/Robot/src/robottest/RobotBuilder.java	2018-01-01 14:51:05.763735300 -0700
+++ new/apps/tests/Robot/src/robottest/RobotBuilder.java	2018-01-01 14:51:05.380712800 -0700
@@ -25,7 +25,6 @@
 package robottest;
 
 import com.sun.glass.events.KeyEvent;
-import com.sun.glass.ui.Robot;
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
@@ -50,6 +49,7 @@
 import javafx.scene.layout.Pane;
 import javafx.scene.layout.VBox;
 import javafx.scene.paint.Color;
+import javafx.scene.robot.Robot;
 import javafx.scene.shape.Rectangle;
 import javafx.stage.Popup;
 import javafx.stage.Stage;
@@ -211,14 +211,14 @@
                 } else if (field.isFocused()) {
                     stop();
                     Robot robot = com.sun.glass.ui.Application.GetApplication().createRobot();
-                    robot.keyPress(KeyEvent.VK_T);
-                    robot.keyRelease(KeyEvent.VK_T);
-                    robot.keyPress(KeyEvent.VK_E);
-                    robot.keyRelease(KeyEvent.VK_E);
-                    robot.keyPress(KeyEvent.VK_S);
-                    robot.keyRelease(KeyEvent.VK_S);
-                    robot.keyPress(KeyEvent.VK_T);
-                    robot.keyRelease(KeyEvent.VK_T);
+                    robot.keyPress(KeyCode.T);
+                    robot.keyRelease(KeyCode.T);
+                    robot.keyPress(KeyCode.E);
+                    robot.keyRelease(KeyCode.E);
+                    robot.keyPress(KeyCode.S);
+                    robot.keyRelease(KKeyCode.S);
+                    robot.keyPress(KeyCode.T);
+                    robot.keyRelease(KeyCode.T);
                     robot.destroy();
                     new AnimationTimer() {
                         long startTime = System.nanoTime();
@@ -251,8 +251,8 @@
         final Robot robot =
                     com.sun.glass.ui.Application.GetApplication().createRobot();
         robot.mouseMove(x, y);
-        robot.mousePress(Robot.MOUSE_LEFT_BTN);
-        robot.mouseRelease(Robot.MOUSE_LEFT_BTN);
+        robot.mousePress(MouseButton.PRIMARY);
+        robot.mouseRelease(MouseButton.PRIMARY);
 
         new AnimationTimer() {
             long startTime = System.nanoTime();
@@ -264,8 +264,8 @@
                 } else if (lv.isFocused()) {
                     stop();
                     robot.mouseWheel(-5);
-                    robot.mousePress(Robot.MOUSE_LEFT_BTN);
-                    robot.mouseRelease(Robot.MOUSE_LEFT_BTN);
+                    robot.mousePress(MouseButton.PRIMARY);
+                    robot.mouseRelease(MouseButton.PRIMARY);
                     robot.destroy();
                     new AnimationTimer() {
                         long startTime = System.nanoTime();
--- old/buildSrc/addExports	2018-01-01 14:51:07.616841100 -0700
+++ new/buildSrc/addExports	2018-01-01 14:51:07.257821300 -0700
@@ -13,3 +13,4 @@
 # ----------------------------------------------------------------------
 #
 # end temporary --add-exports
+--add-exports javafx.graphics/javafx.scene.robot=ALL-UNNAMED
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/Application.java	2018-01-01 14:51:09.412944700 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/Application.java	2018-01-01 14:51:09.047924300 -0700
@@ -33,12 +33,12 @@
 import java.nio.IntBuffer;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
-import java.util.ArrayList;
-import java.util.Iterator;
 import java.util.List;
 import java.util.Map;
 import java.util.LinkedList;
 
+import javafx.scene.robot.Robot;
+
 public abstract class Application {
 
     private final static String DEFAULT_NAME = "java";
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/Robot.java	2018-01-01 14:51:11.194046900 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/Robot.java	2018-01-01 14:51:10.835026700 -0700
@@ -1,271 +0,0 @@
-/*
- * Copyright (c) 2010, 2016, Oracle and/or its affiliates. All rights reserved.
- * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
- *
- * This code is free software; you can redistribute it and/or modify it
- * under the terms of the GNU General Public License version 2 only, as
- * published by the Free Software Foundation.  Oracle designates this
- * particular file as subject to the "Classpath" exception as provided
- * by Oracle in the LICENSE file that accompanied this code.
- *
- * This code is distributed in the hope that it will be useful, but WITHOUT
- * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
- * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
- * version 2 for more details (a copy is included in the LICENSE file that
- * accompanied this code).
- *
- * You should have received a copy of the GNU General Public License version
- * 2 along with this work; if not, write to the Free Software Foundation,
- * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
- * or visit www.oracle.com if you need additional information or have any
- * questions.
- */
-package com.sun.glass.ui;
-
-import static com.sun.javafx.FXPermissions.CREATE_ROBOT_PERMISSION;
-import java.lang.annotation.Native;
-import java.nio.IntBuffer;
-
-public abstract class Robot {
-
-    @Native public static final int MOUSE_LEFT_BTN   = 1;
-    @Native public static final int MOUSE_RIGHT_BTN  = 2;
-    @Native public static final int MOUSE_MIDDLE_BTN = 4;
-
-    protected abstract void _create();
-    protected Robot() {
-        // Ensure proper permission
-        final SecurityManager sm = System.getSecurityManager();
-        if (sm != null) {
-            sm.checkPermission(CREATE_ROBOT_PERMISSION);
-        }
-        Application.checkEventThread();
-        _create();
-    }
-
-    protected abstract void _destroy();
-    public void destroy() {
-        Application.checkEventThread();
-        _destroy();
-    }
-
-    protected abstract void _keyPress(int code);
-    /**
-     * Generate a key pressed event.
-     * @param code key code for this event
-     */
-    public void keyPress(int code) {
-        Application.checkEventThread();
-        _keyPress(code);
-    }
-
-    protected abstract void _keyRelease(int code);
-    /**
-     * Generate a key released event.
-     *
-     * @param code key code for this event
-     */
-    public void keyRelease(int code) {
-        Application.checkEventThread();
-        _keyRelease(code);
-    }
-
-    protected abstract void _mouseMove(int x, int y);
-    /**
-     * Generate a mouse moved event.
-     *
-     * @param x screen coordinate x
-     * @param y screen coordinate y
-     */
-    public void mouseMove(int x, int y) {
-        Application.checkEventThread();
-        _mouseMove(x, y);
-    }
-
-    protected abstract void _mousePress(int buttons);
-    /**
-     * Generate a mouse press event with specified buttons mask.
-     *
-     * Up to 32-buttons mice are supported. Other buttons are inaccessible
-     * by the robot. Bits 0, 1, and 2 mean LEFT, RIGHT, and MIDDLE mouse buttons
-     * respectively.
-     *
-     * @param buttons buttons to have generated the event
-     */
-    public void mousePress(int buttons) {
-        Application.checkEventThread();
-        _mousePress(buttons);
-    }
-
-    protected abstract void _mouseRelease(int buttons);
-    /**
-     * Generate a mouse release event with specified buttons mask.
-     *
-     * @param buttons buttons to have generated the event
-     */
-    public void mouseRelease(int buttons) {
-        Application.checkEventThread();
-        _mouseRelease(buttons);
-    }
-
-    protected abstract void _mouseWheel(int wheelAmt);
-    /**
-     * Generate a mouse wheel event.
-     *
-     * @param wheelAmt amount the wheel has turned of wheel turning
-     */
-    public void mouseWheel(int wheelAmt) {
-        Application.checkEventThread();
-        _mouseWheel(wheelAmt);
-    }
-
-    protected abstract int _getMouseX();
-    public int getMouseX() {
-        Application.checkEventThread();
-        return _getMouseX();
-    }
-
-    protected abstract int _getMouseY();
-    public int getMouseY() {
-        Application.checkEventThread();
-        return _getMouseY();
-    }
-
-    protected abstract int _getPixelColor(int x, int y);
-    /**
-     * Returns pixel color at specified screen coordinates in IntARGB format.
-     */
-    public int getPixelColor(int x, int y) {
-        Application.checkEventThread();
-        return _getPixelColor(x, y);
-    }
-
-    // Subclasses must override and implement at least one of the following two
-    // _getScreenCapture methods
-
-    protected void _getScreenCapture(int x, int y, int width, int height, int[] data) {
-        throw new UnsupportedOperationException("Not implementated in the base class");
-    }
-
-    protected Pixels _getScreenCapture(int x, int y, int width, int height, boolean isHiDPI) {
-        Screen mainScreen = Screen.getMainScreen();
-        float uiScaleX = mainScreen.getPlatformScaleX();
-        float uiScaleY = mainScreen.getPlatformScaleY();
-        int data[];
-        int dw, dh;
-        if (uiScaleX == 1.0f && uiScaleY == 1.0f) {
-            data = new int[width * height];
-            _getScreenCapture(x, y, width, height, data);
-            dw = width;
-            dh = height;
-        } else {
-            int pminx = (int) Math.floor(x * uiScaleX);
-            int pminy = (int) Math.floor(y * uiScaleY);
-            int pmaxx = (int) Math.ceil((x + width) * uiScaleX);
-            int pmaxy = (int) Math.ceil((y + height) * uiScaleY);
-            int pwidth = pmaxx - pminx;
-            int pheight = pmaxy - pminy;
-            int tmpdata[] = new int[pwidth * pheight];
-            _getScreenCapture(pminx, pminy, pwidth, pheight, tmpdata);
-            if (isHiDPI) {
-                data = tmpdata;
-                dw = pwidth;
-                dh = pheight;
-            } else {
-                data = new int[width * height];
-                int index = 0;
-                for (int iy = 0; iy < height; iy++) {
-                    float rely = ((y + iy + 0.5f) * uiScaleY) - (pminy + 0.5f);
-                    int irely = (int) Math.floor(rely);
-                    int fracty = (int) ((rely - irely) * 256);
-                    for (int ix = 0; ix < width; ix++) {
-                        float relx = ((x + ix + 0.5f) * uiScaleX) - (pminx + 0.5f);
-                        int irelx = (int) Math.floor(relx);
-                        int fractx = (int) ((relx - irelx) * 256);
-                        data[index++] =
-                            interp(tmpdata, irelx, irely, pwidth, pheight, fractx, fracty);
-                    }
-                }
-                dw = width;
-                dh = height;
-            }
-        }
-        return Application.GetApplication().createPixels(dw, dh, IntBuffer.wrap(data));
-    }
-
-    /**
-     * Returns a capture of the specified rectangular area of the screen.
-     *
-     * If {@code isHiDPI} argument is {@code true}, the returned Pixels object
-     * dimensions may differ from the requested {@code width} and {@code
-     * height} depending on how many physical pixels the area occupies on the
-     * screen.  E.g. in HiDPI mode on the Mac (aka Retina display) the pixels
-     * are doubled, and thus a screen capture of an area of size (10x10) pixels
-     * will result in a Pixels object with dimensions (20x20). Calling code
-     * should use the returned objects's getWidth() and getHeight() methods
-     * to determine the image size.
-     *
-     * If (@code isHiDPI) is {@code false}, the returned Pixels object is of
-     * the requested size. Note that in this case the image may be scaled in
-     * order to fit to the requested dimensions if running on a HiDPI display.
-     */
-    public Pixels getScreenCapture(int x, int y, int width, int height, boolean isHiDPI) {
-        Application.checkEventThread();
-        return _getScreenCapture(x, y, width, height, isHiDPI);
-    }
-
-    /**
-     * Returns a capture of the specified area of the screen.
-     * It is equivalent to calling getScreenCapture(x, y, width, height, false),
-     * i.e. this method takes a "LowDPI" screen shot.
-     */
-    public Pixels getScreenCapture(int x, int y, int width, int height) {
-        return getScreenCapture(x, y, width, height, false);
-    }
-
-    private static int interp(int pixels[], int x, int y, int w, int h, int fractx1, int fracty1) {
-        int fractx0 = 256 - fractx1;
-        int fracty0 = 256 - fracty1;
-        int i = y * w + x;
-        int rgb00 = (x < 0 || y < 0 || x >= w || y >= h) ? 0 : pixels[i];
-        if (fracty1 == 0) {
-            // No interplation with pixels[y+1]
-            if (fractx1 == 0) {
-                // No interpolation with any neighbors
-                return rgb00;
-            }
-            int rgb10 = (y < 0 || x+1 >= w || y >= h) ? 0 : pixels[i+1];
-            return interp(rgb00, rgb10, fractx0, fractx1);
-        } else if (fractx1 == 0) {
-            // No interpolation with pixels[x+1]
-            int rgb01 = (x < 0 || x >= w || y+1 >= h) ? 0 : pixels[i+w];
-            return interp(rgb00, rgb01, fracty0, fracty1);
-        } else {
-            // All 4 neighbors must be interpolated
-            int rgb10 = (y < 0 || x+1 >= w || y >= h) ? 0 : pixels[i+1];
-            int rgb01 = (x < 0 || x >= w || y+1 >= h) ? 0 : pixels[i+w];
-            int rgb11 = (x+1 >= w || y+1 >= h) ? 0 : pixels[i+w+1];
-            return interp(interp(rgb00, rgb10, fractx0, fractx1),
-                          interp(rgb01, rgb11, fractx0, fractx1),
-                          fracty0, fracty1);
-        }
-    }
-
-    private static int interp(int rgb0, int rgb1, int fract0, int fract1) {
-        int a0 = (rgb0 >> 24) & 0xff;
-        int r0 = (rgb0 >> 16) & 0xff;
-        int g0 = (rgb0 >>  8) & 0xff;
-        int b0 = (rgb0      ) & 0xff;
-        int a1 = (rgb1 >> 24) & 0xff;
-        int r1 = (rgb1 >> 16) & 0xff;
-        int g1 = (rgb1 >>  8) & 0xff;
-        int b1 = (rgb1      ) & 0xff;
-        int a = (a0 * fract0 + a1 * fract1) >> 8;
-        int r = (r0 * fract0 + r1 * fract1) >> 8;
-        int g = (g0 * fract0 + g1 * fract1) >> 8;
-        int b = (b0 * fract0 + b1 * fract1) >> 8;
-        return (a << 24) | (r << 16) | (g << 8) | b;
-    }
-}
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/gtk/GtkApplication.java	2018-01-01 14:51:12.993150100 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/gtk/GtkApplication.java	2018-01-01 14:51:12.627129700 -0700
@@ -30,7 +30,6 @@
 import com.sun.glass.ui.Cursor;
 import com.sun.glass.ui.InvokeLaterDispatcher;
 import com.sun.glass.ui.Pixels;
-import com.sun.glass.ui.Robot;
 import com.sun.glass.ui.Screen;
 import com.sun.glass.ui.Size;
 import com.sun.glass.ui.Timer;
@@ -51,6 +50,8 @@
 import java.util.concurrent.CountDownLatch;
 import java.lang.annotation.Native;
 
+import javafx.scene.robot.Robot;
+
 final class GtkApplication extends Application implements
                                     InvokeLaterDispatcher.InvokeLaterSubmitter {
     private static final String SWT_INTERNAL_CLASS =
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/gtk/GtkRobot.java	2018-01-01 14:51:14.790253800 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/gtk/GtkRobot.java	2018-01-01 14:51:14.417232100 -0700
@@ -24,54 +24,108 @@
  */
 package com.sun.glass.ui.gtk;
 
-import com.sun.glass.ui.*;
-import java.nio.IntBuffer;
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.MouseButton;
+import javafx.scene.paint.Color;
+import javafx.scene.robot.Robot;
+
+import com.sun.glass.ui.Application;
+import com.sun.glass.ui.GlassRobot;
+import com.sun.glass.ui.Screen;
 
 final class GtkRobot extends Robot {
 
     @Override
-    protected void _create() {
+    protected void create() {
         // no-op
     }
 
     @Override
-    protected void _destroy() {
+    protected void destroy() {
         // no-op
     }
 
     @Override
+    public void keyPress(KeyCode code) {
+        Application.checkEventThread();
+        _keyPress(code.getCode());
+    }
+
     protected native void _keyPress(int code);
 
     @Override
+    public void keyRelease(KeyCode code) {
+        Application.checkEventThread();
+        _keyRelease(code.getCode());
+    }
+
     protected native void _keyRelease(int code);
 
     @Override
-    protected native void _mouseMove(int x, int y);
+    public native void mouseMove(int x, int y);
+
+    @Override
+    public void mousePress(MouseButton button) {
+        Application.checkEventThread();
+        _mousePress(GlassRobot.convertToRobotMouseButton(button));
+    }
+
+    @Override
+    public void mousePress(MouseButton... buttons) {
+        Application.checkEventThread();
+        _mousePress(GlassRobot.convertToRobotMouseButton(buttons));
+    }
+
+    protected native void _mousePress(int button);
 
     @Override
-    protected native void _mousePress(int buttons);
+    public void mouseRelease(MouseButton button) {
+        Application.checkEventThread();
+        _mouseRelease(GlassRobot.convertToRobotMouseButton(button));
+    }
 
     @Override
+    public void mouseRelease(MouseButton... buttons) {
+        Application.checkEventThread();
+        _mouseRelease(GlassRobot.convertToRobotMouseButton(buttons));
+    }
+
     protected native void _mouseRelease(int buttons);
 
     @Override
+    protected void mouseWheel(int wheelAmt) {
+        Application.checkEventThread();
+        _mouseWheel(wheelAmt);
+    }
+
     protected native void _mouseWheel(int wheelAmt);
 
     @Override
+    public int getMouseX() {
+        Application.checkEventThread();
+        return _getMouseX();
+    }
+
     protected native int _getMouseX();
 
     @Override
+    public int getMouseY() {
+        Application.checkEventThread();
+        return _getMouseY();
+    }
+
     protected native int _getMouseY();
 
     @Override
-    protected int _getPixelColor(int x, int y) {
+    public Color getPixelColor(int x, int y) {
+        Application.checkEventThread();
         Screen mainScreen = Screen.getMainScreen();
         x = (int) Math.floor((x + 0.5) * mainScreen.getPlatformScaleX());
         y = (int) Math.floor((y + 0.5) * mainScreen.getPlatformScaleY());
         int[] result = new int[1];
-        _getScreenCapture(x, y, 1, 1, result);
-        return result[0];
+        getScreenCapture(x, y, 1, 1, result);
+        return GlassRobot.convertFromIntArgb(result[0]);
     }
 
-    @Override native protected void _getScreenCapture(int x, int y, int width, int height, int[] data);
+    @Override native protected void getScreenCapture(int x, int y, int width, int height, int[] data);
 }
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/ios/IosApplication.java	2018-01-01 14:51:16.626359400 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/ios/IosApplication.java	2018-01-01 14:51:16.243338000 -0700
@@ -25,15 +25,24 @@
 
 package com.sun.glass.ui.ios;
 
-import com.sun.glass.ui.*;
+import com.sun.glass.ui.Application;
 import com.sun.glass.ui.CommonDialogs.ExtensionFilter;
 import com.sun.glass.ui.CommonDialogs.FileChooserResult;
+import com.sun.glass.ui.Cursor;
+import com.sun.glass.ui.Pixels;
+import com.sun.glass.ui.Screen;
+import com.sun.glass.ui.Size;
+import com.sun.glass.ui.Timer;
+import com.sun.glass.ui.View;
+import com.sun.glass.ui.Window;
+
 import java.io.File;
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
 import java.security.AccessController;
 import java.security.PrivilegedAction;
-import java.util.List;
+
+import javafx.scene.robot.Robot;
 
 public final class IosApplication extends Application {
 
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/ios/IosRobot.java	2018-01-01 14:51:18.415462000 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/ios/IosRobot.java	2018-01-01 14:51:18.046441400 -0700
@@ -25,8 +25,13 @@
 
 package com.sun.glass.ui.ios;
 
-import com.sun.glass.ui.*;
-import java.nio.IntBuffer;
+import com.sun.glass.ui.Application;
+import com.sun.glass.ui.GlassRobot;
+
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.MouseButton;
+import javafx.scene.paint.Color;
+import javafx.scene.robot.Robot;
 
 /**
  * iOS platform implementation class of test automation Robot.
@@ -37,38 +42,44 @@
 
     // init and create native robot object
     private native long _init();
-    @Override protected void _create() {
+
+    @Override protected void create() {
+        Application.checkEventThread();
         ptr = _init();
     }
 
     // release native robot object
     private native void _destroy(long ptr);
-    @Override protected void _destroy() {
+    @Override protected void destroy() {
+        Application.checkEventThread();
         _destroy(ptr);
         ptr = 0;
     }
 
     // synthesize key press
     private native void _keyPress(long ptr, int code);
-    @Override protected void _keyPress(int code) {
+    @Override public void keyPress(KeyCode code) {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
-        _keyPress(ptr, code);
+        _keyPress(ptr, code.getCode());
     }
 
     // synthesize key release
     private native void _keyRelease(long ptr, int code);
-    @Override protected void _keyRelease(int code) {
+    @Override public void keyRelease(KeyCode code) {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
-        _keyRelease(ptr, code);
+        _keyRelease(ptr, code.getCode());
     }
 
     // synthesize mouse motion
     private native void _mouseMove(long ptr, int x, int y);
-    @Override protected void _mouseMove(int x, int y) {
+    @Override public void mouseMove(int x, int y) {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
@@ -77,24 +88,45 @@
 
     // synthesize mouse press of buttons
     private native void _mousePress(long ptr, int buttons);
-    @Override protected void _mousePress(int buttons) {
+    @Override public void mousePress(MouseButton button) {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
-        _mousePress(ptr, buttons);
+        _mousePress(ptr, GlassRobot.convertToRobotMouseButton(button));
+    }
+
+    @Override
+    public void mousePress(MouseButton... buttons) {
+        Application.checkEventThread();
+        if (ptr == 0) {
+            return;
+        }
+        _mousePress(ptr, GlassRobot.convertToRobotMouseButton(buttons));
     }
 
     // synthesize mouse release of buttons
     private native void _mouseRelease(long ptr, int buttons);
-    @Override protected void _mouseRelease(int buttons) {
+    @Override public void mouseRelease(MouseButton button) {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
-        _mouseRelease(ptr, buttons);
+        _mouseRelease(ptr, GlassRobot.convertToRobotMouseButton(button));
+    }
+
+    @Override
+    public void mouseRelease(MouseButton... buttons) {
+        Application.checkEventThread();
+        if (ptr == 0) {
+            return;
+        }
+        _mouseRelease(ptr, GlassRobot.convertToRobotMouseButton(buttons));
     }
 
     private native void _mouseWheel(long ptr, int wheelAmt);
-    @Override protected void _mouseWheel(int wheelAmt) {
+    @Override protected void mouseWheel(int wheelAmt) {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
@@ -103,7 +135,8 @@
 
     // get x-coordinate of mouse location
     private native int _getMouseX(long ptr);
-    @Override protected int _getMouseX() {
+    @Override public int getMouseX() {
+        Application.checkEventThread();
         if (ptr == 0) {
             return 0;
         }
@@ -112,7 +145,8 @@
 
     // get x-coordinate of mouse location
     private native int _getMouseY(long ptr);
-    @Override protected int _getMouseY() {
+    @Override public int getMouseY() {
+        Application.checkEventThread();
         if (ptr == 0) {
             return 0;
         }
@@ -120,22 +154,23 @@
     }
 
     private native int _getPixelColor(long ptr, int x, int y);
-    @Override protected int _getPixelColor(int x, int y) {
+    @Override public Color getPixelColor(int x, int y) {
+        Application.checkEventThread();
         if (ptr == 0) {
-            return 0;
+            return GlassRobot.convertFromIntArgb(0);
         }
-        return _getPixelColor(ptr, x, y);
+        return GlassRobot.convertFromIntArgb(_getPixelColor(ptr, x, y));
     }
 
-    // capture bitmap image of (x, y, x + width, y + height) area
-    native private void _getScreenCapture(long ptr, int x, int y, int width, int height, int[] data);
-    @Override protected Pixels _getScreenCapture(int x, int y, int width, int height, boolean isHiDPI) {
+    @Override
+    protected void getScreenCapture(int x, int y, int width, int height, int[] data) {
+        Application.checkEventThread();
         if (ptr == 0) {
-            return null;
+            return;
         }
-        int data[] = new int[width * height];
         _getScreenCapture(ptr, x, y, width, height, data);
-        return Application.GetApplication().createPixels(width, height, IntBuffer.wrap(data));
     }
+
+    native private void _getScreenCapture(long ptr, int x, int y, int width, int height, int[] data);
 }
 
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/mac/MacApplication.java	2018-01-01 14:51:20.221566200 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/mac/MacApplication.java	2018-01-01 14:51:19.848544800 -0700
@@ -24,10 +24,22 @@
  */
 package com.sun.glass.ui.mac;
 
-import com.sun.glass.ui.*;
+import com.sun.glass.ui.Accessible;
+import com.sun.glass.ui.Application;
 import com.sun.glass.ui.CommonDialogs.ExtensionFilter;
 import com.sun.glass.ui.CommonDialogs.FileChooserResult;
 import com.sun.glass.events.KeyEvent;
+import com.sun.glass.ui.Cursor;
+import com.sun.glass.ui.InvokeLaterDispatcher;
+import com.sun.glass.ui.Menu;
+import com.sun.glass.ui.MenuBar;
+import com.sun.glass.ui.MenuItem;
+import com.sun.glass.ui.Pixels;
+import com.sun.glass.ui.Screen;
+import com.sun.glass.ui.Size;
+import com.sun.glass.ui.Timer;
+import com.sun.glass.ui.View;
+import com.sun.glass.ui.Window;
 
 import java.io.File;
 import java.nio.ByteBuffer;
@@ -36,6 +48,8 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
+import javafx.scene.robot.Robot;
+
 final class MacApplication extends Application implements InvokeLaterDispatcher.InvokeLaterSubmitter {
 
     private native static void _initIDs(boolean disableSyncRendering);
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/mac/MacRobot.java	2018-01-01 14:51:22.015668800 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/mac/MacRobot.java	2018-01-01 14:51:21.647648400 -0700
@@ -24,7 +24,15 @@
  */
 package com.sun.glass.ui.mac;
 
-import com.sun.glass.ui.*;
+import com.sun.glass.ui.Application;
+import com.sun.glass.ui.GlassRobot;
+import com.sun.glass.ui.Pixels;
+
+import javafx.scene.image.Image;
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.MouseButton;
+import javafx.scene.paint.Color;
+import javafx.scene.robot.Robot;
 
 /**
  * MacOSX platform implementation class for Robot.
@@ -34,65 +42,108 @@
     // TODO: get rid of native Robot object
     private long ptr;
 
-    private native long _init();
-    @Override protected void _create() {
+    native private long _init();
+    @Override protected void create() {
+        Application.checkEventThread();
         ptr = _init();
     }
 
-    private native void _destroy(long ptr);
-    @Override protected void _destroy() {
+    native protected void _destroy(long ptr);
+    @Override protected void destroy() {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
         _destroy(ptr);
     }
 
-    @Override native protected void _keyPress(int code);
-    @Override native protected void _keyRelease(int code);
+    native protected void _keyPress(int code);
 
-    private native void _mouseMove(long ptr, int x, int y);
-    @Override protected void _mouseMove(int x, int y) {
+    @Override public void keyPress(KeyCode code) {
+        Application.checkEventThread();
+        _keyPress(code.getCode());
+    }
+
+    native protected void _keyRelease(int code);
+
+    @Override public void keyRelease(KeyCode code) {
+        Application.checkEventThread();
+        _keyRelease(code.getCode());
+    }
+
+    native protected void _mouseMove(long ptr, int x, int y);
+    @Override public void mouseMove(int x, int y) {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
         _mouseMove(ptr, x, y);
     }
 
-    private native void _mousePress(long ptr, int buttons);
-    @Override protected void _mousePress(int buttons) {
+    native protected void _mousePress(long ptr, int buttons);
+    @Override public void mousePress(MouseButton button) {
+        Application.checkEventThread();
+        if (ptr == 0) {
+            return;
+        }
+        _mousePress(ptr, GlassRobot.convertToRobotMouseButton(button));
+    }
+
+    @Override public void mousePress(MouseButton... buttons) {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
-        _mousePress(ptr, buttons);
+        _mousePress(ptr, GlassRobot.convertToRobotMouseButton(buttons));
     }
 
-    private native void _mouseRelease(long ptr, int buttons);
-    @Override protected void _mouseRelease(int buttons) {
+    native protected void _mouseRelease(long ptr, int buttons);
+    @Override public void mouseRelease(MouseButton button) {
+        Application.checkEventThread();
         if (ptr == 0) {
             return;
         }
-        _mouseRelease(ptr, buttons);
+        _mouseRelease(ptr, GlassRobot.convertToRobotMouseButton(button));
     }
 
-    @Override native protected void _mouseWheel(int wheelAmt);
+    @Override public void mouseRelease(MouseButton... buttons) {
+        Application.checkEventThread();
+        if (ptr == 0) {
+            return;
+        }
+        _mouseRelease(ptr, GlassRobot.convertToRobotMouseButton(buttons));
+    }
 
-    private native int _getMouseX(long ptr);
-    @Override protected int _getMouseX() {
+    native protected void _mouseWheel(int wheelAmt);
+    @Override protected void mouseWheel(int wheelAmt) {
+        Application.checkEventThread();
+        _mouseWheel(wheelAmt);
+    }
+
+    native protected int _getMouseX(long ptr);
+    @Override public int getMouseX() {
+        Application.checkEventThread();
         if (ptr == 0) {
             return 0;
         }
         return _getMouseX(ptr);
     }
 
-    private native int _getMouseY(long ptr);
-    @Override protected int _getMouseY() {
+    native protected int _getMouseY(long ptr);
+    @Override public int getMouseY() {
+        Application.checkEventThread();
         if (ptr == 0) {
             return 0;
         }
         return _getMouseY(ptr);
     }
 
-    @Override native protected int _getPixelColor(int x, int y);
-    @Override native protected Pixels _getScreenCapture(int x, int y, int width, int height, boolean isHiDPI);
+    native protected int _getPixelColor(int x, int y);
+    @Override public Color getPixelColor(int x, int y) {
+        Application.checkEventThread();
+        return GlassRobot.convertFromIntArgb(_getPixelColor(x, y));
+    }
+
+    @Override native protected void getScreenCapture(int x, int y, int width, int height, int[] data);
 }
 
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/MonocleApplication.java	2018-01-01 14:51:23.829773100 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/MonocleApplication.java	2018-01-01 14:51:23.459752400 -0700
@@ -29,16 +29,15 @@
 import com.sun.glass.ui.CommonDialogs.FileChooserResult;
 import com.sun.glass.ui.Cursor;
 import com.sun.glass.ui.Pixels;
-import com.sun.glass.ui.Robot;
 import com.sun.glass.ui.Screen;
 import com.sun.glass.ui.Size;
 import com.sun.glass.ui.Timer;
 import com.sun.glass.ui.View;
 import com.sun.glass.ui.Window;
 import javafx.collections.SetChangeListener;
+import javafx.scene.robot.Robot;
 
 import java.io.File;
-import java.lang.reflect.Constructor;
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
 import java.security.AccessController;
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/MonocleRobot.java	2018-01-01 14:51:25.628876700 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/monocle/MonocleRobot.java	2018-01-01 14:51:25.246855100 -0700
@@ -26,9 +26,12 @@
 package com.sun.glass.ui.monocle;
 
 import com.sun.glass.events.MouseEvent;
-import com.sun.glass.ui.Pixels;
-import com.sun.glass.ui.Robot;
-import javafx.application.Platform;
+import com.sun.glass.ui.Application;
+import com.sun.glass.ui.GlassRobot;
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.MouseButton;
+import javafx.scene.paint.Color;
+import javafx.scene.robot.Robot;
 
 import java.nio.ByteBuffer;
 import java.nio.IntBuffer;
@@ -36,121 +39,177 @@
 
 class MonocleRobot extends Robot {
     @Override
-    protected void _create() {
+    public void create() {
+        // no-op
     }
 
     @Override
-    protected void _destroy() {
+    public void destroy() {
+        // no-op
     }
 
     @Override
-    protected void _keyPress(int code) {
-        Platform.runLater(() -> {
-            KeyState state = new KeyState();
-            KeyInput.getInstance().getState(state);
-            state.pressKey(code);
-            KeyInput.getInstance().setState(state);
-        });
+    public void keyPress(KeyCode code) {
+        Application.checkEventThread();
+        KeyState state = new KeyState();
+        KeyInput.getInstance().getState(state);
+        state.pressKey(code.getCode());
+        KeyInput.getInstance().setState(state);
     }
 
     @Override
-    protected void _keyRelease(int code) {
-        Platform.runLater(() -> {
-            KeyState state = new KeyState();
-            KeyInput.getInstance().getState(state);
-            state.releaseKey(code);
-            KeyInput.getInstance().setState(state);
-        });
+    public void keyRelease(KeyCode code) {
+        Application.checkEventThread();
+        KeyState state = new KeyState();
+        KeyInput.getInstance().getState(state);
+        state.releaseKey(code.getCode());
+        KeyInput.getInstance().setState(state);
     }
 
     @Override
-    protected void _mouseMove(int x, int y) {
-        Platform.runLater(() -> {
-            MouseState state = new MouseState();
-            MouseInput.getInstance().getState(state);
-            state.setX(x);
-            state.setY(y);
-            MouseInput.getInstance().setState(state, false);
-        });
+    public void mouseMove(int x, int y) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        state.setX(x);
+        state.setY(y);
+        MouseInput.getInstance().setState(state, false);
     }
 
-    @Override
-    protected void _mousePress(int buttons) {
-        Platform.runLater(() -> {
-            MouseState state = new MouseState();
-            MouseInput.getInstance().getState(state);
-            if ((buttons & MOUSE_LEFT_BTN) != 0) {
-                state.pressButton(MouseEvent.BUTTON_LEFT);
-            }
-            if ((buttons & MOUSE_MIDDLE_BTN) != 0) {
-                state.pressButton(MouseEvent.BUTTON_OTHER);
-            }
-            if ((buttons & MOUSE_RIGHT_BTN) != 0) {
-                state.pressButton(MouseEvent.BUTTON_RIGHT);
+    private static MouseState convertToMouseState(boolean press, MouseState state, MouseButton button) {
+        switch (button) {
+            case PRIMARY:
+                if (press) {
+                    state.pressButton(MouseEvent.BUTTON_LEFT);
+                } else {
+                    state.releaseButton(MouseEvent.BUTTON_LEFT);
+                }
+                return state;
+            case SECONDARY:
+                if (press) {
+                    state.pressButton(MouseEvent.BUTTON_RIGHT);
+                } else {
+                    state.releaseButton(MouseEvent.BUTTON_RIGHT);
+                }
+                return state;
+            case MIDDLE:
+                if (press) {
+                    state.pressButton(MouseEvent.BUTTON_OTHER);
+                } else {
+                    state.releaseButton(MouseEvent.BUTTON_OTHER);
+                }
+                return state;
+            default: throw new IllegalArgumentException("MouseButton: " + button +
+                    " not supported by Monocle Robot");
+        }
+    }
+
+    private static MouseState convertToMouseState(boolean press, MouseState state, MouseButton... buttons) {
+        for (MouseButton button : buttons) {
+            switch (button) {
+                case PRIMARY:
+                    if (press) {
+                        state.pressButton(MouseEvent.BUTTON_LEFT);
+                    } else {
+                        state.releaseButton(MouseEvent.BUTTON_LEFT);
+                    }
+                    break;
+                case SECONDARY:
+                    if (press) {
+                        state.pressButton(MouseEvent.BUTTON_RIGHT);
+                    } else {
+                        state.releaseButton(MouseEvent.BUTTON_RIGHT);
+                    }
+                    break;
+                case MIDDLE:
+                    if (press) {
+                        state.pressButton(MouseEvent.BUTTON_OTHER);
+                    } else {
+                        state.releaseButton(MouseEvent.BUTTON_OTHER);
+                    }
+                    break;
+                default: throw new IllegalArgumentException("MouseButton: " + button +
+                        " not supported by Monocle Robot");
             }
-            MouseInput.getInstance().setState(state, false);
-        });
+        }
+        return state;
     }
 
     @Override
-    protected void _mouseRelease(int buttons) {
-        Platform.runLater(() -> {
-            MouseState state = new MouseState();
-            MouseInput.getInstance().getState(state);
-            if ((buttons & MOUSE_LEFT_BTN) != 0) {
-                state.releaseButton(MouseEvent.BUTTON_LEFT);
-            }
-            if ((buttons & MOUSE_MIDDLE_BTN) != 0) {
-                state.releaseButton(MouseEvent.BUTTON_OTHER);
-            }
-            if ((buttons & MOUSE_RIGHT_BTN) != 0) {
-                state.releaseButton(MouseEvent.BUTTON_RIGHT);
-            }
-            MouseInput.getInstance().setState(state, false);
-        });
+    public void mousePress(MouseButton button) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        MouseInput.getInstance().setState(convertToMouseState(true, state, button), false);
     }
 
     @Override
-    protected void _mouseWheel(int wheelAmt) {
-        Platform.runLater(() -> {
-            MouseState state = new MouseState();
-            MouseInput mouse = MouseInput.getInstance();
-            mouse.getState(state);
-            int direction = wheelAmt < 0
-                            ? MouseState.WHEEL_DOWN
-                            : MouseState.WHEEL_UP;
-            for (int i = 0; i < Math.abs(wheelAmt); i++) {
-                state.setWheel(direction);
-                mouse.setState(state, false);
-                state.setWheel(MouseState.WHEEL_NONE);
-                mouse.setState(state, false);
-            }
-        });
+    public void mousePress(MouseButton... buttons) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        MouseInput.getInstance().setState(convertToMouseState(true, state, buttons), false);
+    }
+
+    @Override
+    public void mouseRelease(MouseButton button) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        MouseInput.getInstance().setState(convertToMouseState(false, state, button), false);
+    }
+
+    @Override
+    public void mouseRelease(MouseButton... buttons) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput.getInstance().getState(state);
+        MouseInput.getInstance().setState(convertToMouseState(false, state, buttons), false);
     }
 
     @Override
-    protected int _getMouseX() {
+    protected void mouseWheel(int wheelAmt) {
+        Application.checkEventThread();
+        MouseState state = new MouseState();
+        MouseInput mouse = MouseInput.getInstance();
+        mouse.getState(state);
+        int direction = wheelAmt < 0
+                        ? MouseState.WHEEL_DOWN
+                        : MouseState.WHEEL_UP;
+        for (int i = 0; i < Math.abs(wheelAmt); i++) {
+            state.setWheel(direction);
+            mouse.setState(state, false);
+            state.setWheel(MouseState.WHEEL_NONE);
+            mouse.setState(state, false);
+        }
+    }
+
+    @Override
+    public int getMouseX() {
+        Application.checkEventThread();
         MouseState state = new MouseState();
         MouseInput.getInstance().getState(state);
         return state.getX();
     }
 
     @Override
-    protected int _getMouseY() {
+    public int getMouseY() {
+        Application.checkEventThread();
         MouseState state = new MouseState();
         MouseInput.getInstance().getState(state);
         return state.getY();
     }
 
     @Override
-    protected int _getPixelColor(int x, int y) {
+    public Color getPixelColor(int x, int y) {
+        Application.checkEventThread();
         NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
         final int byteDepth = screen.getDepth() >>> 3;
         final int bwidth = screen.getWidth();
         final int bheight = screen.getHeight();
 
         if (x < 0 || x > bwidth || y < 0 || y > bheight) {
-            return 0;
+            return GlassRobot.convertFromIntArgb(0);
         }
 
         synchronized (NativeScreen.framebufferSwapLock) {
@@ -161,29 +220,28 @@
                 ShortBuffer shortbuf = buffer.asShortBuffer();
 
                 int v = shortbuf.get((y * bwidth) + x);
-                int red = (int) ((v & 0xF800) >> 11) << 3;
-                int green = (int) ((v & 0x7E0) >> 5) << 2;
-                int blue = (int) (v & 0x1F) << 3;
+                int red = (v & 0xF800) >> 11 << 3;
+                int green = (v & 0x7E0) >> 5 << 2;
+                int blue = (v & 0x1F) << 3;
 
                 int p = (0xff000000
                         | (red << 16)
                         | (green << 8)
                         | blue);
-                return p;
+                return GlassRobot.convertFromIntArgb(p);
             } else if (byteDepth >= 4) {
                 IntBuffer intbuf = buffer.asIntBuffer();
-                return intbuf.get((y * bwidth) + x);
+                return GlassRobot.convertFromIntArgb(intbuf.get((y * bwidth) + x));
             } else {
-                throw new RuntimeException("Unknown bit depth");
+                throw new RuntimeException("Unknown bit depth: " + byteDepth);
             }
         }
     }
 
     @Override
-    protected Pixels _getScreenCapture(int x, int y, int width, int height,
-            boolean isHiDPI) {
+    protected void getScreenCapture(int x, int y, int width, int height, int[] data) {
+        Application.checkEventThread();
         NativeScreen screen = NativePlatformFactory.getNativePlatform().getScreen();
-        final int byteDepth = screen.getDepth() >>> 3;
         final int scrWidth = screen.getWidth();
         final int scrHeight = screen.getHeight();
 
@@ -191,20 +249,18 @@
             IntBuffer buffer = screen.getScreenCapture().asIntBuffer();
 
             if (x == 0 && y == 0 && width == scrWidth && height == scrHeight) {
-                return new MonoclePixels(width, height, buffer);
+                // Easy case, the entire screen is being captured.
+                System.arraycopy(buffer.array(), 0, data, 0, buffer.array().length);
+                return;
             }
 
-            IntBuffer ret = IntBuffer.allocate(width * height);
             int rowStop = Math.min(y + height, scrHeight);
             int colStop = Math.min(x + width, scrWidth);
             for (int row = y; row < rowStop; row++) {
                 for (int col = x; col < colStop; col++) {
-                    ret.put(buffer.get(row * scrWidth + col));
+                    data[row * scrWidth + col] = buffer.get(row * scrWidth + col);
                 }
             }
-
-            ret.rewind();
-            return new MonoclePixels(width, height, ret);
         }
     }
 }
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/win/WinApplication.java	2018-01-01 14:51:27.647992600 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/win/WinApplication.java	2018-01-01 14:51:27.281971700 -0700
@@ -24,10 +24,18 @@
  */
 package com.sun.glass.ui.win;
 
-import com.sun.glass.ui.*;
+import com.sun.glass.ui.Accessible;
+import com.sun.glass.ui.Application;
 import com.sun.glass.ui.CommonDialogs.ExtensionFilter;
 import com.sun.glass.ui.CommonDialogs.FileChooserResult;
-import com.sun.glass.utils.NativeLibLoader;
+import com.sun.glass.ui.Cursor;
+import com.sun.glass.ui.InvokeLaterDispatcher;
+import com.sun.glass.ui.Pixels;
+import com.sun.glass.ui.Screen;
+import com.sun.glass.ui.Size;
+import com.sun.glass.ui.Timer;
+import com.sun.glass.ui.View;
+import com.sun.glass.ui.Window;
 import com.sun.prism.impl.PrismSettings;
 import com.sun.javafx.tk.Toolkit;
 
@@ -37,6 +45,8 @@
 import java.security.AccessController;
 import java.security.PrivilegedAction;
 
+import javafx.scene.robot.Robot;
+
 final class WinApplication extends Application implements InvokeLaterDispatcher.InvokeLaterSubmitter {
     static float   overrideUIScale;
 
--- old/modules/javafx.graphics/src/main/java/com/sun/glass/ui/win/WinRobot.java	2018-01-01 14:51:29.544102200 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/win/WinRobot.java	2018-01-01 14:51:29.159079800 -0700
@@ -24,32 +24,92 @@
  */
 package com.sun.glass.ui.win;
 
-import com.sun.glass.ui.*;
-import java.nio.IntBuffer;
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.MouseButton;
+import javafx.scene.paint.Color;
+import javafx.scene.robot.Robot;
+
+import com.sun.glass.ui.Application;
+import com.sun.glass.ui.GlassRobot;
 
 /**
  * MS Windows platform implementation class for Robot.
  */
 final class WinRobot extends Robot {
 
-    @Override protected void _create() {
+    @Override protected void create() {
         // no-op
     }
-    @Override protected void _destroy() {
+    @Override protected void destroy() {
         // no-op
     }
 
-    @Override native protected void _keyPress(int code);
-    @Override native protected void _keyRelease(int code);
+    native protected void _keyPress(int code);
+    @Override public void keyPress(KeyCode code) {
+        Application.checkEventThread();
+        _keyPress(code.getCode());
+    }
+
+    native protected void _keyRelease(int code);
+    @Override public void keyRelease(KeyCode code) {
+        Application.checkEventThread();
+        _keyRelease(code.getCode());
+    }
+
 
-    @Override native protected void _mouseMove(int x, int y);
-    @Override native protected void _mousePress(int buttons);
-    @Override native protected void _mouseRelease(int buttons);
-    @Override native protected void _mouseWheel(int wheelAmt);
+    native protected void _mouseMove(int x, int y);
+    @Override public void mouseMove(int x, int y) {
+        Application.checkEventThread();
+        _mouseMove(x, y);
+    }
 
-    @Override native protected int _getMouseX();
-    @Override native protected int _getMouseY();
+    native protected void _mousePress(int buttons);
+    @Override public void mousePress(MouseButton button) {
+        Application.checkEventThread();
+        _mousePress(GlassRobot.convertToRobotMouseButton(button));
+    }
+
+    @Override
+    public void mousePress(MouseButton... buttons) {
+        Application.checkEventThread();
+        _mousePress(GlassRobot.convertToRobotMouseButton(buttons));
+    }
+
+    native protected void _mouseRelease(int buttons);
+    @Override public void mouseRelease(MouseButton button) {
+        Application.checkEventThread();
+        _mouseRelease(GlassRobot.convertToRobotMouseButton(button));
+    }
+
+    @Override
+    public void mouseRelease(MouseButton... buttons) {
+        Application.checkEventThread();
+        _mouseRelease(GlassRobot.convertToRobotMouseButton(buttons));
+    }
+
+    native protected void _mouseWheel(int wheelAmt);
+    @Override protected void mouseWheel(int wheelAmt) {
+        Application.checkEventThread();
+        _mouseWheel(wheelAmt);
+    }
+
+    native protected int _getMouseX();
+    @Override public int getMouseX() {
+        Application.checkEventThread();
+        return _getMouseX();
+    }
+
+    native protected int _getMouseY();
+    @Override public int getMouseY() {
+        Application.checkEventThread();
+        return _getMouseY();
+    }
+
+    native protected int _getPixelColor(int x, int y);
+    @Override public Color getPixelColor(int x, int y) {
+        Application.checkEventThread();
+        return GlassRobot.convertFromIntArgb(_getPixelColor(x, y));
+    }
 
-    @Override native protected int _getPixelColor(int x, int y);
-    @Override native protected void _getScreenCapture(int x, int y, int width, int height, int[] data);
+    @Override native protected void getScreenCapture(int x, int y, int width, int height, int[] data);
 }
--- old/modules/javafx.graphics/src/main/java/javafx/application/Application.java	2018-01-01 14:51:31.465212500 -0700
+++ new/modules/javafx.graphics/src/main/java/javafx/application/Application.java	2018-01-01 14:51:31.082190100 -0700
@@ -25,19 +25,17 @@
 
 package javafx.application;
 
-import java.security.AccessController;
-import java.security.PrivilegedAction;
 import java.util.List;
 import java.util.Map;
 
 import javafx.application.Preloader.PreloaderNotification;
 import javafx.scene.Scene;
+import javafx.scene.robot.Robot;
 import javafx.stage.Stage;
 
 import com.sun.javafx.application.LauncherImpl;
 import com.sun.javafx.application.ParametersImpl;
 import com.sun.javafx.application.PlatformImpl;
-import com.sun.javafx.css.StyleManager;
 
 /**
  * Application class from which JavaFX applications extend.
@@ -525,4 +523,15 @@
             PlatformImpl.setPlatformUserAgentStylesheet(url);
         }
     }
+
+    /**
+     * Creates and returns a {@link javafx.scene.robot.Robot} which can be used for
+     * simulating user interaction.
+     *
+     * @return a new {@link javafx.scene.robot.Robot} instance
+     * @since 11
+     */
+    public static Robot createRobot() {
+        return com.sun.glass.ui.Application.GetApplication().createRobot();
+    }
 }
--- old/modules/javafx.graphics/src/main/java/module-info.java	2018-01-01 14:51:33.361320800 -0700
+++ new/modules/javafx.graphics/src/main/java/module-info.java	2018-01-01 14:51:32.990300700 -0700
@@ -53,6 +53,7 @@
     exports javafx.scene.input;
     exports javafx.scene.layout;
     exports javafx.scene.paint;
+    exports javafx.scene.robot;
     exports javafx.scene.shape;
     exports javafx.scene.text;
     exports javafx.scene.transform;
--- old/modules/javafx.graphics/src/main/native-glass/gtk/GlassRobot.cpp	2018-01-01 14:51:35.170425100 -0700
+++ new/modules/javafx.graphics/src/main/native-glass/gtk/GlassRobot.cpp	2018-01-01 14:51:34.774403300 -0700
@@ -31,6 +31,7 @@
 #include <gdk/gdk.h>
 #include <gdk/gdkx.h>
 
+#include <com_sun_glass_ui_GlassRobot.h>
 #include <com_sun_glass_ui_gtk_GtkRobot.h>
 #include <com_sun_glass_events_MouseEvent.h>
 #include "glass_general.h"
@@ -142,13 +143,13 @@
 static void mouseButtons(jint buttons, gboolean press)
 {
     Display *xdisplay = gdk_x11_get_default_xdisplay();
-    if (buttons & com_sun_glass_ui_gtk_GtkRobot_MOUSE_LEFT_BTN) {
+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_LEFT_BTN) {
         XTestFakeButtonEvent(xdisplay, 1, press, CurrentTime);
     }
-    if (buttons & com_sun_glass_ui_gtk_GtkRobot_MOUSE_MIDDLE_BTN) {
+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_MIDDLE_BTN) {
         XTestFakeButtonEvent(xdisplay, 2, press, CurrentTime);
     }
-    if (buttons & com_sun_glass_ui_gtk_GtkRobot_MOUSE_RIGHT_BTN) {
+    if (buttons & com_sun_glass_ui_GlassRobot_MOUSE_RIGHT_BTN) {
         XTestFakeButtonEvent(xdisplay, 3, press, CurrentTime);
     }
 
@@ -240,10 +241,10 @@
 
 /*
  * Class:     com_sun_glass_ui_gtk_GtkRobot
- * Method:    _getScreenCapture
+ * Method:    getScreenCapture
  * Signature: (IIII[I)V
  */
-JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkRobot__1getScreenCapture
+JNIEXPORT void JNICALL Java_com_sun_glass_ui_gtk_GtkRobot_getScreenCapture
   (JNIEnv * env, jobject obj, jint x, jint y, jint width, jint height, jintArray data)
 {
     (void)obj;
--- old/modules/javafx.graphics/src/main/native-glass/mac/GlassRobot.m	2018-01-01 14:51:36.959528400 -0700
+++ new/modules/javafx.graphics/src/main/native-glass/mac/GlassRobot.m	2018-01-01 14:51:36.595507200 -0700
@@ -426,13 +426,13 @@
 
 /*
  * Class:     com_sun_glass_ui_mac_MacRobot
- * Method:    _getScreenCapture
- * Signature: (IIIIZ)Lcom/sun/glass/ui/Pixels;
+ * Method:    getScreenCapture
+ * Signature: (IIII[I)V
  */
-JNIEXPORT jobject JNICALL Java_com_sun_glass_ui_mac_MacRobot__1getScreenCapture
-(JNIEnv *env, jobject jrobot, jint x, jint y, jint width, jint height, jboolean isHiDPI)
+JNIEXPORT void JNICALL Java_com_sun_glass_ui_mac_MacRobot_getScreenCapture
+(JNIEnv *env, jobject jrobot, jint x, jint y, jint width, jint height, jintArray data)
 {
-    LOG("Java_com_sun_glass_ui_mac_MacRobot__1getScreenCapture");
+    LOG("Java_com_sun_glass_ui_mac_MacRobot_getScreenCapture");
 
     jobject pixels = NULL;
 
@@ -440,11 +440,17 @@
     GLASS_POOL_ENTER
     {
         CGRect bounds = CGRectMake((CGFloat)x, (CGFloat)y, (CGFloat)width, (CGFloat)height);
+        // installLayoutTestColorProfile();
         CGImageRef screenImage = CGWindowListCreateImage(bounds, kCGWindowListOptionOnScreenOnly, kCGNullWindowID, kCGWindowImageDefault);
         if (screenImage != NULL)
         {
             jint pixWidth, pixHeight;
 
+            jboolean isHiDPI = FALSE;
+
+            if ([[NSScreen mainScreen] respondsToSelector:@selector(backingScaleFactor)]) {
+                isHiDPI = [[NSScreen mainScreen] backingScaleFactor] > 1.0;
+            }
             if (isHiDPI) {
                 pixWidth = (jint)CGImageGetWidth(screenImage);
                 pixHeight = (jint)CGImageGetHeight(screenImage);
@@ -477,32 +483,13 @@
                     CGContextDrawImage(jPicContextRef, zeroBounds, screenImage);
                     CGContextFlush(jPicContextRef);
 
-                    // cleanup
-                    CGContextRelease(jPicContextRef);
-                    (*env)->ReleaseIntArrayElements(env, pixelArray, javaPixels, 0);
-
-                    jclass applicationClass =
-                        [GlassHelper ClassForName:"com.sun.glass.ui.Application" withEnv:env];
-                    if (!applicationClass) return NULL;
-
-                    jfloat scale = (*env)->CallStaticFloatMethod(env,
-                            applicationClass,
-                            javaIDs.Application.getScaleFactor, x, y, width, height);
-                    if ((*env)->ExceptionCheck(env)) return NULL;
-
-                    // create Pixels
-                    pixels = (*env)->CallStaticObjectMethod(env, applicationClass,
-                                                            javaIDs.Application.createPixels,
-                                                            pixWidth, pixHeight,
-                                                            pixelArray, scale, scale);
-                    if ((*env)->ExceptionCheck(env)) return NULL;
+                    (*env)->SetIntArrayRegion(env, data, 0, (jsize)pixWidth * pixHeight, pixelArray);
                 }
             }
 
             CGImageRelease(screenImage);
         }
+        // restoreUserColorProfile();
     }
     GLASS_POOL_EXIT;
-
-    return pixels;
 }
--- old/modules/javafx.graphics/src/main/native-glass/win/Robot.cpp	2018-01-01 14:51:38.747630500 -0700
+++ new/modules/javafx.graphics/src/main/native-glass/win/Robot.cpp	2018-01-01 14:51:38.383610000 -0700
@@ -28,7 +28,6 @@
 
 #include "KeyTable.h"
 
-#include "com_sun_glass_ui_Robot.h"
 #include "com_sun_glass_ui_win_WinRobot.h"
 #include "GlassScreen.h"
 
@@ -294,10 +293,10 @@
 
 /*
  * Class:     com_sun_glass_ui_win_WinRobot
- * Method:    _getScreenCapture
+ * Method:    getScreenCapture
  * Signature: (IIII[I;)V
  */
-JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot__1getScreenCapture
+JNIEXPORT void JNICALL Java_com_sun_glass_ui_win_WinRobot_getScreenCapture
     (JNIEnv *env, jobject jrobot, jint x, jint y, jint width, jint height, jintArray pixelArray)
 {
     int numPixels = width * height;
--- old/modules/javafx.graphics/src/test/addExports	2018-01-01 14:51:40.553734700 -0700
+++ new/modules/javafx.graphics/src/test/addExports	2018-01-01 14:51:40.193714700 -0700
@@ -45,6 +45,7 @@
 --add-exports javafx.graphics/com.sun.scenario.effect.light=ALL-UNNAMED
 --add-exports javafx.graphics/com.sun.scenario=ALL-UNNAMED
 --add-opens javafx.graphics/javafx.scene=ALL-UNNAMED
+--add-opens javafx.graphics/javafx.scene.robot=ALL-UNNAMED
 --add-opens javafx.graphics/javafx.scene.layout=ALL-UNNAMED
 #
 --add-exports java.base/sun.util.logging=ALL-UNNAMED
--- /dev/null	2017-12-20 20:02:36.219685500 -0700
+++ new/modules/javafx.graphics/src/main/java/com/sun/glass/ui/GlassRobot.java	2018-01-01 14:51:41.956815800 -0700
@@ -0,0 +1,172 @@
+/*
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package com.sun.glass.ui;
+
+import java.lang.annotation.Native;
+import java.nio.ByteBuffer;
+import java.nio.IntBuffer;
+
+import javafx.scene.image.PixelWriter;
+import javafx.scene.image.WritableImage;
+import javafx.scene.input.MouseButton;
+import javafx.scene.paint.Color;
+
+import com.sun.javafx.image.PixelUtils;
+
+public class GlassRobot {
+
+    @Native public static final int MOUSE_LEFT_BTN    = 1 << 0;
+    @Native public static final int MOUSE_RIGHT_BTN   = 1 << 1;
+    @Native public static final int MOUSE_MIDDLE_BTN  = 1 << 2;
+
+    public static int convertToRobotMouseButton(MouseButton button) {
+        switch (button) {
+            case PRIMARY: return MOUSE_LEFT_BTN;
+            case SECONDARY: return MOUSE_RIGHT_BTN;
+            case MIDDLE: return MOUSE_MIDDLE_BTN;
+            default: throw new IllegalArgumentException("MouseButton: " + button + " not supported by Robot");
+        }
+    }
+
+    public static int convertToRobotMouseButton(MouseButton[] buttons) {
+        int ret = 0;
+        for (MouseButton button : buttons) {
+            switch (button) {
+                case PRIMARY: ret &= MOUSE_LEFT_BTN; break;
+                case SECONDARY: ret &= MOUSE_RIGHT_BTN; break;
+                case MIDDLE: ret &= MOUSE_MIDDLE_BTN; break;
+                default: throw new IllegalArgumentException("MouseButton: " + button + " not supported by Robot");
+            }
+        }
+        return ret;
+    }
+
+    public static Color convertFromIntArgb(int color) {
+        int alpha = (color >> 24) & 0xFF;
+        int red   = (color >> 16) & 0xFF;
+        int green = (color >>  8) & 0xFF;
+        int blue  =  color        & 0xFF;
+        return new Color(red / 255d, green / 255d, blue / 255d, alpha / 255d);
+    }
+
+    public static WritableImage convertFromPixels(Pixels pixels) {
+        int width = pixels.getWidth();
+        int height = pixels.getHeight();
+        WritableImage image = new WritableImage(width, height);
+
+        int bytesPerComponent = pixels.getBytesPerComponent();
+        if (bytesPerComponent == 4) {
+            IntBuffer intBuffer = (IntBuffer) pixels.getPixels();
+            writeIntBufferToImage(intBuffer, image);
+        }
+        else if (bytesPerComponent == 1) {
+            ByteBuffer byteBuffer = (ByteBuffer) pixels.getPixels();
+            writeByteBufferToImage(byteBuffer, image);
+        }
+
+        return image;
+    }
+
+    private static void writeIntBufferToImage(IntBuffer intBuffer, WritableImage image) {
+        PixelWriter pixelWriter = image.getPixelWriter();
+        double width = image.getWidth();
+        double height = image.getHeight();
+
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                int argb = intBuffer.get();
+                pixelWriter.setArgb(x, y, argb);
+            }
+        }
+    }
+
+    private static void writeByteBufferToImage(ByteBuffer byteBuffer, WritableImage image) {
+        PixelWriter pixelWriter = image.getPixelWriter();
+        double width = image.getWidth();
+        double height = image.getHeight();
+
+        int format = Pixels.getNativeFormat();
+
+        for (int y = 0; y < height; y++) {
+            for (int x = 0; x < width; x++) {
+                if (format == Pixels.Format.BYTE_BGRA_PRE) {
+                    pixelWriter.setArgb(x, y, PixelUtils.PretoNonPre(bgraPreToRgbaPre(byteBuffer.getInt())));
+                } else if (format == Pixels.Format.BYTE_ARGB) {
+                    pixelWriter.setArgb(x, y, byteBuffer.getInt());
+                }
+            }
+        }
+    }
+
+    private static int bgraPreToRgbaPre(int bgraPre) {
+        return (bgraPre & 0xff) | ((bgraPre & 0xff) << 8) |
+                ((bgraPre & 0xff) << 16) | (bgraPre << 24);
+    }
+
+    public static int interp(int pixels[], int x, int y, int w, int h, int fractx1, int fracty1) {
+        int fractx0 = 256 - fractx1;
+        int fracty0 = 256 - fracty1;
+        int i = y * w + x;
+        int rgb00 = (x < 0 || y < 0 || x >= w || y >= h) ? 0 : pixels[i];
+        if (fracty1 == 0) {
+            // No interpolation with pixels[y+1]
+            if (fractx1 == 0) {
+                // No interpolation with any neighbors
+                return rgb00;
+            }
+            int rgb10 = (y < 0 || x+1 >= w || y >= h) ? 0 : pixels[i+1];
+            return interp(rgb00, rgb10, fractx0, fractx1);
+        } else if (fractx1 == 0) {
+            // No interpolation with pixels[x+1]
+            int rgb01 = (x < 0 || x >= w || y+1 >= h) ? 0 : pixels[i+w];
+            return interp(rgb00, rgb01, fracty0, fracty1);
+        } else {
+            // All 4 neighbors must be interpolated
+            int rgb10 = (y < 0 || x+1 >= w || y >= h) ? 0 : pixels[i+1];
+            int rgb01 = (x < 0 || x >= w || y+1 >= h) ? 0 : pixels[i+w];
+            int rgb11 = (x+1 >= w || y+1 >= h) ? 0 : pixels[i+w+1];
+            return interp(interp(rgb00, rgb10, fractx0, fractx1),
+                    interp(rgb01, rgb11, fractx0, fractx1),
+                    fracty0, fracty1);
+        }
+    }
+
+    public static int interp(int rgb0, int rgb1, int fract0, int fract1) {
+        int a0 = (rgb0 >> 24) & 0xff;
+        int r0 = (rgb0 >> 16) & 0xff;
+        int g0 = (rgb0 >>  8) & 0xff;
+        int b0 = (rgb0      ) & 0xff;
+        int a1 = (rgb1 >> 24) & 0xff;
+        int r1 = (rgb1 >> 16) & 0xff;
+        int g1 = (rgb1 >>  8) & 0xff;
+        int b1 = (rgb1      ) & 0xff;
+        int a = (a0 * fract0 + a1 * fract1) >> 8;
+        int r = (r0 * fract0 + r1 * fract1) >> 8;
+        int g = (g0 * fract0 + g1 * fract1) >> 8;
+        int b = (b0 * fract0 + b1 * fract1) >> 8;
+        return (a << 24) | (r << 16) | (g << 8) | b;
+    }
+
+}
--- /dev/null	2017-12-20 20:02:36.219685500 -0700
+++ new/modules/javafx.graphics/src/main/java/javafx/scene/robot/Robot.java	2018-01-01 14:51:43.437900400 -0700
@@ -0,0 +1,383 @@
+/*
+ * Copyright (c) 2010, 2017, Oracle and/or its affiliates. All rights reserved.
+ * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
+ *
+ * This code is free software; you can redistribute it and/or modify it
+ * under the terms of the GNU General Public License version 2 only, as
+ * published by the Free Software Foundation.  Oracle designates this
+ * particular file as subject to the "Classpath" exception as provided
+ * by Oracle in the LICENSE file that accompanied this code.
+ *
+ * This code is distributed in the hope that it will be useful, but WITHOUT
+ * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+ * version 2 for more details (a copy is included in the LICENSE file that
+ * accompanied this code).
+ *
+ * You should have received a copy of the GNU General Public License version
+ * 2 along with this work; if not, write to the Free Software Foundation,
+ * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
+ * or visit www.oracle.com if you need additional information or have any
+ * questions.
+ */
+package javafx.scene.robot;
+
+import static com.sun.javafx.FXPermissions.CREATE_ROBOT_PERMISSION;
+
+import java.nio.IntBuffer;
+
+import javafx.geometry.Point2D;
+import javafx.geometry.Rectangle2D;
+import javafx.geometry.VerticalDirection;
+import javafx.scene.image.Image;
+import javafx.scene.input.KeyCode;
+import javafx.scene.input.MouseButton;
+import javafx.scene.paint.Color;
+import javafx.stage.Screen;
+
+import com.sun.glass.ui.Application;
+import com.sun.glass.ui.GlassRobot;
+
+/**
+ * A {@code Robot} is used for simulating user interaction such as
+ * typing keys on the keyboard and using the mouse as well as capturing
+ * graphical information without requiring a {@link javafx.scene.Scene}
+ * instance.
+ * <p>
+ * A {@code Robot} instance can be obtained by calling
+ * {@link javafx.application.Application#createRobot()}.
+ *
+ * @since 11
+ */
+public abstract class Robot {
+
+    /**
+     * Initializes any state necessary for this {@code Robot}. Called by
+     * the {@code Robot} constructor.
+     */
+    protected abstract void create();
+
+    protected Robot() {
+        // Ensure we have proper permission for creating a robot.
+        final SecurityManager sm = System.getSecurityManager();
+        if (sm != null) {
+            sm.checkPermission(CREATE_ROBOT_PERMISSION);
+        }
+
+        Application.checkEventThread();
+        create();
+    }
+
+    /**
+     * Frees any resources allocated by this {@code Robot}.
+     */
+    protected abstract void destroy();
+
+    /**
+     * Presses the specified {@link KeyCode} key.
+     *
+     * @param keyCode the key to press
+     */
+    public abstract void keyPress(KeyCode keyCode);
+
+    /**
+     * Releases the specified {@link KeyCode} key.
+     *
+     * @param keyCode the key to release
+     */
+    public abstract void keyRelease(KeyCode keyCode);
+
+    /**
+     * Types the specified {@link KeyCode} key.
+     * <p>
+     * This is a convenience method that is equivalent to calling
+     * {@link #keyPress(KeyCode)} followed by {@link #keyRelease(KeyCode)}.
+     *
+     * @param keyCode the key to type
+     */
+    public final void keyType(KeyCode keyCode) {
+        Application.checkEventThread();
+        keyPress(keyCode);
+        keyRelease(keyCode);
+    }
+
+    /**
+     * Returns the current mouse x-position.
+     *
+     * @return the current mouse x-position
+     */
+    public abstract int getMouseX();
+
+    /**
+     * Returns the current mouse y-position.
+     *
+     * @return the current mouse y-position
+     */
+    public abstract int getMouseY();
+
+    /**
+     * Returns the current mouse (x, y) coordinates as a {@link Point2D}.
+     *
+     * @return the current mouse (x,y) coordinates
+     */
+    public Point2D getMousePosition() {
+        Application.checkEventThread();
+        return new Point2D(getMouseX(), getMouseY());
+    }
+
+    /**
+     * Moves the mouse to the specified (x,y) screen coordinates.
+     *
+     * @param x screen coordinate x to move the mouse to
+     * @param y screen coordinate y to move the mouse to
+     */
+    public abstract void mouseMove(int x, int y);
+
+    /**
+     * Moves the mouse to the (x,y) screen coordinates specified by the
+     * given {@code location}.
+     *
+     * @param location the (x,y) coordinates to move the mouse to
+     */
+    public final void mouseMove(Point2D location) {
+        Application.checkEventThread();
+        mouseMove((int) location.getX(), (int) location.getY());
+    }
+
+    /**
+     * Presses the specified {@link MouseButton}.
+     *
+     * @param button the mouse button to press
+     */
+    public abstract void mousePress(MouseButton button);
+
+    /**
+     * Presses the specified {@link MouseButton}s at the same time.
+     *
+     * @param buttons the mouse buttons to press at the same time
+     */
+    public abstract void mousePress(MouseButton... buttons);
+
+    /**
+     * Releases the specified {@link MouseButton}.
+     *
+     * @param button the mouse button to release
+     */
+    public abstract void mouseRelease(MouseButton button);
+
+    /**
+     * Releases the specified {@link MouseButton}s at the same time.
+     *
+     * @param buttons the mouse buttons to release at the same time
+     */
+    public abstract void mouseRelease(MouseButton... buttons);
+
+    /**
+     * Scrolls the mouse wheel by the specified amount in the specified vertical
+     * {@code direction}.
+     *
+     * @param wheelAmt the amount to scroll the wheel
+     * @param direction the vertical direction, either up or down, to scroll in
+     */
+    public final void mouseWheel(int wheelAmt, VerticalDirection direction) {
+        Application.checkEventThread();
+        switch (direction) {
+            case UP:
+                mouseWheel(wheelAmt);
+                break;
+            case DOWN:
+                mouseWheel(-wheelAmt);
+                break;
+            default: throw new IllegalArgumentException("unsupported direction: " + direction);
+        }
+    }
+
+    /**
+     * Scrolls the mouse wheel by the specified amount. Positive {@code wheelAmt}s
+     * scroll up whereas negative scroll down.
+     *
+     * @param wheelAmt the (signed) amount to scroll the wheel
+     */
+    protected abstract void mouseWheel(int wheelAmt);
+
+    /**
+     * Returns the {@link Color} of the pixel at the specified screen coordinates.
+     *
+     * @param x the x coordinate to get the pixel color from
+     * @param y the y coordinate to get the pixel color from
+     * @return the pixel color at the specified screen coordinates
+     */
+    public abstract Color getPixelColor(int x, int y);
+
+    /**
+     * Returns the {@link Color} of the pixel at the screen coordinates specified
+     * by {@code location}.
+     *
+     * @param location the (x,y) coordinates to get the pixel color from
+     * @return the pixel color at the specified screen coordinates
+     */
+    public final Color getPixelColor(Point2D location) {
+        Application.checkEventThread();
+        return getPixelColor((int) location.getX(), (int) location.getY());
+    }
+
+    /**
+     * Returns an {@code Image} containing the specified rectangular area of the screen.
+     * <p>
+     * If the {@code scaleToFit} argument is {@literal false}, the returned
+     * {@code Image} object dimensions may differ from the requested {@code width}
+     * and {@code height} depending on how many physical pixels the area occupies
+     * on the screen. E.g. in HiDPI mode on the Mac (aka Retina display) the pixels
+     * are doubled, and thus a screen capture of an area of size (10x10) pixels
+     * will result in an {@code Image} with dimensions (20x20). Calling code should
+     * use the returned images's {@link Image#getWidth() and {@link Image#getHeight()
+     * methods to determine the actual image size.
+     * <p>
+     * If {@code scaleToFit} is {@literal true}, the returned {@code Image} is of
+     * the requested size. Note that in this case the image will be scaled in
+     * order to fit to the requested dimensions if necessary such as when running
+     * on a HiDPI display.
+     *
+     * @param x the starting x-position of the rectangular area to capture
+     * @param y the starting y-position of the rectangular area to capture
+     * @param width the width of the rectangular area to capture
+     * @param height the height of the rectangular area to capture
+     * @param scaleToFit If {@literal true} the returned {@code Image} will be
+     * scaled to fit the request dimensions, if necessary. Otherwise the size
+     * of the returned image will depend on the output scale (DPI) of the primary
+     * screen.
+     */
+    public final Image getScreenCapture(int x, int y, int width, int height, boolean scaleToFit) {
+        Application.checkEventThread();
+        Screen primaryScreen = Screen.getPrimary();
+        double outputScaleX = primaryScreen.getOutputScaleX();
+        double outputScaleY = primaryScreen.getOutputScaleY();
+        int data[];
+        int dw, dh;
+        if (outputScaleX == 1.0f && outputScaleY == 1.0f) {
+            // No scaling with be necessary regardless of if "scaleToFit" is set or not.
+            data = new int[width * height];
+            getScreenCapture(x, y, width, height, data);
+            dw = width;
+            dh = height;
+        } else {
+            // Compute the absolute pixel bounds that the requested size will fill given
+            // the display's scale.
+            int pminx = (int) Math.floor(x * outputScaleX);
+            int pminy = (int) Math.floor(y * outputScaleY);
+            int pmaxx = (int) Math.ceil((x + width) * outputScaleX);
+            int pmaxy = (int) Math.ceil((y + height) * outputScaleY);
+            int pwidth = pmaxx - pminx;
+            int pheight = pmaxy - pminy;
+            int tmpdata[] = new int[pwidth * pheight];
+            getScreenCapture(pminx, pminy, pwidth, pheight, tmpdata);
+            if (!scaleToFit) {
+                data = tmpdata;
+                dw = pwidth;
+                dh = pheight;
+            } else {
+                // We must resize the image to fit the requested bounds. This means
+                // resizing the pixel data array which we accomplish using bilinear (?)
+                // interpolation.
+                data = new int[width * height];
+                int index = 0;
+                for (int iy = 0; iy < height; iy++) {
+                    double rely = ((y + iy + 0.5f) * outputScaleY) - (pminy + 0.5f);
+                    int irely = (int) Math.floor(rely);
+                    int fracty = (int) ((rely - irely) * 256);
+                    for (int ix = 0; ix < width; ix++) {
+                        double relx = ((x + ix + 0.5f) * outputScaleX) - (pminx + 0.5f);
+                        int irelx = (int) Math.floor(relx);
+                        int fractx = (int) ((relx - irelx) * 256);
+                        data[index++] =
+                                GlassRobot.interp(tmpdata, irelx, irely, pwidth, pheight, fractx, fracty);
+                    }
+                }
+                dw = width;
+                dh = height;
+            }
+        }
+
+        return GlassRobot.convertFromPixels(Application.GetApplication().createPixels(
+                dw, dh, IntBuffer.wrap(data)));
+    }
+
+    /**
+     * Returns an {@code Image} containing the specified rectangular area of the screen.
+     * <p>
+     * It is equivalent to calling {@code getScreenCapture(x, y, width, height, true)},
+     * i.e. this method scales the image to fit the requested size.
+     *
+     * @param x the starting x-position of the rectangular area to capture
+     * @param y the starting y-position of the rectangular area to capture
+     * @param width the width of the rectangular area to capture
+     * @param height the height of the rectangular area to capture
+     * @return the screen capture of the specified {@code region} as an {@link Image}
+     */
+    public final Image getScreenCapture(int x, int y, int width, int height) {
+        Application.checkEventThread();
+        return getScreenCapture(x, y, width, height, true);
+    }
+
+    /**
+     * Returns an {@code Image} containing the specified rectangular area of the screen.
+     * <p>
+     * It is equivalent to calling {@code getScreenCapture(x, y, width, height, true)},
+     * i.e. this method scales the image to fit the requested size.
+     *
+     * @param region the rectangular area of the screen to capture
+     * @return the screen capture of the specified {@code region} as an {@link Image}
+     */
+    public final Image getScreenCapture(Rectangle2D region) {
+        Application.checkEventThread();
+        return getScreenCapture((int) region.getMinX(), (int) region.getMinY(),
+                (int) region.getWidth(), (int) region.getHeight(), true);
+    }
+
+    /**
+     * Returns an {@code Image} containing the specified rectangular area of the screen.
+     * <p>
+     * If the {@code scaleToFit} argument is {@literal false}, the returned
+     * {@code Image} object dimensions may differ from the requested {@code width}
+     * and {@code height} depending on how many physical pixels the area occupies
+     * on the screen. E.g. in HiDPI mode on the Mac (aka Retina display) the pixels
+     * are doubled, and thus a screen capture of an area of size (10x10) pixels
+     * will result in an {@code Image} with dimensions (20x20). Calling code should
+     * use the returned images's {@link Image#getWidth() and {@link Image#getHeight()
+     * methods to determine the actual image size.
+     * <p>
+     * If {@code scaleToFit} is {@literal true}, the returned {@code Image} is of
+     * the requested size. Note that in this case the image will be scaled in
+     * order to fit to the requested dimensions if necessary such as when running
+     * on a HiDPI display.
+     *
+     * @param region the rectangular area of the screen to capture
+     * @param scaleToFit If {@literal true} the returned {@code Image} will be
+     * scaled to fit the request dimensions, if necessary. Otherwise the size
+     * of the returned image will depend on the output scale (DPI) of the primary
+     * screen.
+     * @return the screen capture of the specified {@code region} as an {@link Image}
+     */
+    public final Image getScreenCapture(Rectangle2D region, boolean scaleToFit) {
+        Application.checkEventThread();
+        return getScreenCapture((int) region.getMinX(), (int) region.getMinY(),
+                (int) region.getWidth(), (int) region.getHeight(), scaleToFit);
+    }
+
+    /**
+     * Captures the specified rectangular area of the screen and uses it to fill the given
+     * {@code data} array with the raw pixel data. The data is in RGBA format where each
+     * pixel in the image is encoded as 4 bytes - one for each color component of each
+     * pixel.
+     *
+     * @param x the starting x-position of the rectangular area to capture
+     * @param y the starting y-position of the rectangular area to capture
+     * @param width the width of the rectangular area to capture
+     * @param height the height of the rectangular area to capture
+     * @param data the array to fill with the raw pixel data corresponding to
+     * the captured region
+     */
+    protected abstract void getScreenCapture(int x, int y, int width, int height, int[] data);
+}
